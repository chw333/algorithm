<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0058)http://ace.delos.com/usacoanal/s=1.2.4.5/a=KUUZikBhwYs/83a -->
<HTML><HEAD><TITLE>Analysis 83: Humble Numbers</TITLE>
<META http-equiv=Content-Type content="text/html; charset=iso-8859-1">
<META content="MSHTML 6.00.2719.2200" name=GENERATOR></HEAD>
<BODY background="Analysis 83 Humble Numbers.files/bg3.jpg"><IMG height=118 
src="Analysis 83 Humble Numbers.files/cow1.jpg" width=742> 
<CENTER><B><FONT size=7>Humble Numbers</FONT></B><BR>Russ Cox </CENTER>
<P>We compute the first n humble numbers in the "hum" array. For simplicity of 
implementation, we treat 1 as a humble number, and adjust accordingly. 
<P>Once we have the first k humble numbers and want to compute the k+1st, we do 
the following: <PRE>	for each prime p
		find the minimum humble number h
		  such that h * p is bigger than the last humble number.

	take the smallest h * p found: that's the next humble number.
</PRE>
<P>To speed up the search, we keep an index "pindex" of what h is for each 
prime, and start there rather than at the beginning of the list. <PRE>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;ctype.h&gt;

#define MAXPRIME 100
#define MAXN 100000

long hum[MAXN+1];
int nhum;

int prime[MAXPRIME];
int pindex[MAXPRIME];
int nprime;

void
main(void)
{
    FILE *fin, *fout;
    int i, minp;
    long min;
    int n;

    fin = fopen("humble.in", "r");
    fout = fopen("humble.out", "w");
    assert(fin != NULL &amp;&amp; fout != NULL);

    fscanf(fin, "%d %d", &amp;nprime, &amp;n);
    for(i=0; i&lt;nprime; i++)
	fscanf(fin, "%d", &amp;prime[i]);

    hum[nhum++] = 1;
    for(i=0; i&lt;nprime; i++)
	pindex[i] = 0;

    while(nhum &lt; n+1) {
	min = 0x7FFFFFFF;
	minp = -1;
	for(i=0; i&lt;nprime; i++) {
	    while((double)prime[i] * hum[pindex[i]] &lt;= hum[nhum-1]) 
		pindex[i]++;

	    /* double to avoid overflow problems */
	    if((double)prime[i] * hum[pindex[i]] &lt; min) {
		min = prime[i] * hum[pindex[i]];
		minp = i;
	    }
	}

	hum[nhum++] = min;
	pindex[minp]++;
    }

    fprintf(fout, "%d\n", hum[n]);
    exit(0);
}
</PRE>
<CENTER><A href="http://ace.delos.com/usacogate?a=KUUZikBhwYs">USACO Gateway</A> 
| <A href="mailto:kolstad@ace.delos.com">Comment or Question</A> 
</CENTER></BODY></HTML>
