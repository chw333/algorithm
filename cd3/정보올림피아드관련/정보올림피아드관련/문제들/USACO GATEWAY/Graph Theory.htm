<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0058)http://ace.delos.com/usacotext/s=1.2.1/a=n8UCMGSrVkI/graph -->
<HTML><HEAD><TITLE>Graph Theory</TITLE>
<META http-equiv=Content-Type content="text/html; charset=iso-8859-1">
<META content="MSHTML 6.00.2716.2200" name=GENERATOR></HEAD>
<BODY background="Graph Theory.files/bg3.jpg"><IMG height=118 
src="Graph Theory.files/cow1.jpg" width=742> 
<CENTER><B><FONT size=7>Graph Theory</FONT></B><BR></CENTER>
<H4>What's a Graph?</H4>
<P>Formally, a <I>graph</I> is the following: 
<UL>
  <LI>a collection of <I>vertices</I> V, and 
  <LI>a collection of <I>edges</I> E consisting of pairs of vertices. </LI></UL>
<P>Think of vertices as ``locations''. The set of vertices is the set of all the 
possible locations. In this analogy, edges represent paths between pairs of 
those locations; the set E contains all the paths between the locations. 
<H4>Representation</H4>
<P>The graph is normally represented using that analogy. Vertices are points or 
circles; edges are lines between them. <BR><IMG 
src="Graph Theory.files/graph1.gif"><BR>
<P>In this example graph, V = {1, 2, 3, 4, 5, 6} and E = {(1,3), (1,6), (2,5), 
(3,4), (3,6)}. 
<P>Each <I>vertex</I> is a member of the set V. A vertex is sometimes called a 
<I>node</I>. 
<P>Each <I>edge</I> is a member of the set E. Note that some vertices might not 
be the end point of any edge. Such vertices are termed `isolated'. 
<P>Sometimes, numerical values are associated with edges, specifying lengths or 
costs; such graphs are called <I>edge-weighted</I> graphs (or weighted graphs). 
The value associated with an edge is called the <I>weight</I> of the edge. A 
similar definition holds for node-weighted graphs, 
<H4>Examples of Graphs</H4>
<H5>Telecowmunication (USACO Championship 1996)</H5>
<P>Given a set of computers and a set of wires running between pairs of 
computers, what is the minimum number of machines whose crash causes two given 
machines to be unable to communicate? (The two given machines will not crash.) 
<P>Graph: The vertices of the graph are the computers. The edges are the wires 
between the computers. 
<H5>Sample Problem: Riding The Fences</H5>
<P>Farmer John owns a large number of fences, which he must periodically check 
for integrity. He keeps track of his fences by maintaining a list of points at 
which fences intersect. He records the name of the point and the one or two 
fence names that touch that point. Every fence has two end points, each at some 
intersection point, although the intersection point may be the end point of only 
one fence. 
<P>Given a fence layout, calculate if there is a way for Farmer John to ride his 
horse to all of his fences without riding along a fence more than once. Farmer 
John can start and finish anywhere, but cannot cut across his fields (i.e., the 
only way he can travel between intersection points is along a fence). If there 
is a way, find one way. 
<P>Graph: Farmer John starts at intersection points and travels between the 
points along fences. Thus, the vertices of the underlying graph are the 
intersection points, and the fences represent edges. 
<H5>Knight moves</H5>
<P>Given: Two squares on an 8x8 chessboard. Determine the shortest sequence of 
knight moves from one square to the other. 
<P>Graph: The graph here is harder to see. Each location on the chessboard 
represents a vertex. There is an edge between two positions if it is a legal 
knight move. 
<H5>Overfencing [Kolstad &amp; Schrijvers, Spring 1999 USACO Open]</H5>
<P>Farmer John created a huge maze of fences in a field. He omitted two fence 
segments on the edges, thus creating two ``exits'' for the maze. The maze is a 
`perfect' maze; you can find a way out of the maze from any point inside it. 
<P>Given the layout of the maze, calculate the number of steps required to exit 
the maze from the `worst' point in the maze (the point that is `farther' from 
either exit when walking optimally to the closest exit). 
<P>Here's what one particular W=5, H=3 maze looks like: <BR><TT><FONT 
size=2><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+-+-+-+-+-+<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+-+&nbsp;+-+&nbsp;+&nbsp;+<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;|&nbsp;|<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+&nbsp;+-+-+&nbsp;+&nbsp;+<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+-+&nbsp;+-+-+-+<BR></FONT></TT>
<P>Graph: The vertices of the graph are positions in the grid. There is an edge 
between two vertices if they represent adjacent positions that are not separated 
by a wall. 
<H4>Terminology</H4>Let's look again at the first example graph: <BR><IMG 
src="Graph Theory.files/graph1.gif"><BR>
<P>An edge is a <I>self-loop</I> if it is of the form (u,u). The sample graph 
contains no self-loops. 
<P>A graph is <I>simple</I> if it neither contains self-loops nor contains an 
edge that is repeated in E. A graph is called a <I>multigraph</I> if it contains 
a given edge more than once or contain self-loops. For our discussions, graphs 
are assumed to be simple. The example graph is a simple graph. 
<P>An edge (u,v) is <I>incident</I> to both vertex u and vertex v. For example, 
the edge (1,3) is incident to vertex 3. 
<P>The <I>degree</I> of a vertex is the number of edges which are incident to 
it. For example, vertex 3 has degree 3, while vertex 4 has degree 1. 
<P>Vertex u is <I>adjacent</I> to vertex v if there is some edge to which both 
are incident (that is, there is an edge between them). For example, vertex 2 is 
adjacent to vertex 5. 
<P>A graph is said to be <I>sparse</I> if the total number of edges is small 
compared to the total number possible ((<I>N x (N-1))/2</I>) and <I>dense</I> 
otherwise. For a given graph, whether it is dense or sparse is not well-defined. 

<H4>Directed Graph</H4>
<P>Graphs described thus far are called <I>undirected</I>, as the edges go `both 
ways'. So far, the graphs have connoted that if one can travel from vertex 1 to 
vertex 3, one can also travel from vertex 1 to vertex 3. In other words, (1,3) 
being in the edge set implies (3,1) is in the edge set. 
<P>Sometimes, however, a graph is <I>directed</I>, in which case the edges have 
a direction. In this case, the edges are called <I>arcs</I>. 
<P>Directed graphs are drawn with arrows to show direction. <BR><IMG 
src="Graph Theory.files/graph2.gif"><BR>
<P>The <I>out-degree</I> of a vertex is the number of arcs which <I>begin</I> at 
that vertex. The <I>in-degree</I> of a vertex is the number of arcs which 
<I>end</I> at that vertex. For example, vertex 6 has in-degree 2 and out-degree 
1. 
<P>A graph is assumed to be undirected unless specifically called a directed 
graph. 
<H4>Paths</H4>
<P>A <I>path</I> from vertex <I>u</I> to vertex <I>x</I> is a sequence of 
vertices (<I>v <SUB>0</SUB></I>, <I>v <SUB>1</SUB></I>, ..., <I>v 
<SUB>k</SUB></I>) such that <I>v <SUB>0</SUB></I> = <I>u</I> and <I>v 
<SUB>k</SUB></I> = <I>x</I> and (<I>v <SUB>0</SUB></I>, <I>v <SUB>1</SUB></I>) 
is an edge in the graph, as is (<I>v <SUB>1</SUB></I>, <I>v <SUB>2</SUB></I>), 
(<I>v <SUB>2</SUB></I>, <I>v <SUB>3</SUB></I>), etc. The length of such a path 
is <I>k</I>. 
<P>For example, in the undirected graph above, (4, 3, 1, 6) is a path. <BR><IMG 
src="Graph Theory.files/graph3.gif"><BR>
<P>This path is said to <I>contain</I> the vertices <I>v <SUB>0</SUB></I>, <I>v 
<SUB>1</SUB></I>, etc., as well as the edges (<I>v <SUB>0</SUB></I>, <I>v 
<SUB>1</SUB></I>), (<I>v <SUB>1</SUB></I>, <I>v <SUB>2</SUB></I>), etc. 
<P>Vertex <I>x</I> is said to be <I>reachable</I> from vertex <I>u</I> if a path 
exists from <I>u</I> to <I>x</I>. 
<P>A path is <I>simple</I> if it contains no vertex more than once. 
<P>A path is a <I>cycle</I> if it is a path from some vertex to that same 
vertex. A cycle is <I>simple</I> if it contains no vertex more than once, except 
the start (and end) vertex, which only appears as the first and last vertex in 
the path. 
<P>These definitions extend similarly to directed graphs (e.g., (<I>v 
<SUB>0</SUB></I>, <I>v <SUB>1</SUB></I>), (<I>v <SUB>1</SUB></I>, <I>v 
<SUB>2</SUB></I>), etc. must be arcs). 
<H4>Graph Representation</H4>
<P>The choice of representation of a graph is important, as different 
representations have very different time and space costs. 
<P>The vertices are generally tracked by numbering them, so that one can index 
them just by their number. Thus, the representations focus on how to store the 
<I>edges</I>. 
<H5>Edge List</H5>
<P>The most obvious way to keep track of the edges is to keep a list of the 
pairs of vertices representing the edges in the graph. 
<P>This representation is easy to code, fairly easy to debug, and fairly space 
efficient. However, determining the edges incident to a given vertex is 
expensive, as is determining if two vertices are adjacent. Adding an edge is 
quick, but deleting one is difficult if its location in the list is not known. 
<P>For weighted graphs, this representation also keeps one more number for each 
edge, the edge weight. Extending this data structure to handle directed graphs 
is straightforward. Representing multigraphs is also trivial. 
<H5>Example</H5>The sample undirected graph might be represented as the 
following list of edges: 
<CENTER>
<TABLE border=1>
  <TBODY>
  <TR>
    <TD>&nbsp; </TD>
    <TD><I>V<SUB>1</SUB></I></TD>
    <TD><I>V<SUB>2</SUB></I></TD></TR>
  <TR>
    <TD><I>e<SUB>1</SUB></I></TD>
    <TD>4</TD>
    <TD>3</TD>
  <TR>
    <TD><I>e<SUB>2</SUB></I></TD>
    <TD>1</TD>
    <TD>3</TD>
  <TR>
    <TD><I>e<SUB>3</SUB></I></TD>
    <TD>2</TD>
    <TD>5</TD>
  <TR>
    <TD><I>e<SUB>4</SUB></I></TD>
    <TD>6</TD>
    <TD>1</TD>
  <TR>
    <TD><I>e<SUB>5</SUB></I></TD>
    <TD>3</TD>
    <TD>6</TD></TR></TBODY></TABLE></CENTER>
<H5>Adjacency Matrix</H5>
<P>A second way to represent a graph utilized an <I>adjacency matrix</I>. This 
is a N by N array (N is the number of vertices). The i,j entry contains a 1 if 
the edge (i,j) is in the graph; otherwise it contains a 0. For an undirected 
graph, this matrix is symmetric. 
<P>This representation is easy to code. It's much less space efficient, 
especially for large, sparse graphs. Debugging is harder, as the matrix is 
large. Finding all the edges incident to a given vertex is fairly expensive 
(linear in the number of vertices), but checking if two vertices are adjacent is 
very quick. Adding and removing edges are also very inexpensive operations. 
<P>For weighted graphs, the value of the (i,j) entry is used to store the weight 
of the edge. For an unweighted multigraph, the (i,j) entry can maintain the 
number of edges between the vertices. For a weighted multigraph, it's harder to 
extend this. 
<H5>Example</H5>
<P>The sample undirected graph would be represented by the following adjacency 
matrix: 
<CENTER>
<TABLE border=1>
  <TBODY>
  <TR>
    <TD>&nbsp;</TD>
    <TD><I>V<SUB>1</SUB></I></TD>
    <TD><I>V<SUB>2</SUB></I></TD>
    <TD><I>V<SUB>3</SUB></I></TD>
    <TD><I>V<SUB>4</SUB></I></TD>
    <TD><I>V<SUB>5</SUB></I></TD>
    <TD><I>V<SUB>6</SUB></I></TD>
  <TR>
  <TR>
    <TD align=middle><I>V<SUB>1</SUB></I></TD>
    <TD align=middle>0</TD>
    <TD align=middle>0</TD>
    <TD align=middle>1</TD>
    <TD align=middle>0</TD>
    <TD align=middle>0</TD>
    <TD align=middle>1</TD>
  <TR>
  <TR>
    <TD align=middle><I>V<SUB>2</SUB></I></TD>
    <TD align=middle>0</TD>
    <TD align=middle>0</TD>
    <TD align=middle>0</TD>
    <TD align=middle>0</TD>
    <TD align=middle>1</TD>
    <TD align=middle>0</TD>
  <TR>
  <TR>
    <TD align=middle><I>V<SUB>3</SUB></I></TD>
    <TD align=middle>1</TD>
    <TD align=middle>0</TD>
    <TD align=middle>0</TD>
    <TD align=middle>1</TD>
    <TD align=middle>0</TD>
    <TD align=middle>1</TD>
  <TR>
  <TR>
    <TD align=middle><I>V<SUB>4</SUB></I></TD>
    <TD align=middle>0</TD>
    <TD align=middle>0</TD>
    <TD align=middle>1</TD>
    <TD align=middle>0</TD>
    <TD align=middle>0</TD>
    <TD align=middle>0</TD>
  <TR>
  <TR>
    <TD align=middle><I>V<SUB>5</SUB></I></TD>
    <TD align=middle>0</TD>
    <TD align=middle>1</TD>
    <TD align=middle>0</TD>
    <TD align=middle>0</TD>
    <TD align=middle>0</TD>
    <TD align=middle>0</TD>
  <TR>
  <TR>
    <TD align=middle><I>V<SUB>6</SUB></I></TD>
    <TD align=middle>1</TD>
    <TD align=middle>0</TD>
    <TD align=middle>1</TD>
    <TD align=middle>0</TD>
    <TD align=middle>0</TD>
    <TD align=middle>0</TD>
  <TR></TR></TBODY></TABLE></CENTER>
<P>It is sometimes helpful to use the fact that the (i,j) entry of the adjacency 
matrix raised to the k-th power gives the number of paths from vertex i to 
vertex j consisting of exactly k edges. 
<H5>Adjacency List</H5>
<P>The third representation of a matrix is to keep track of all the edges 
incident to a given vertex. This can be done by using an array of length N, 
where N is the number of vertices. The i<SUP>th</SUP> entry in this array is a 
list of the edges incident to i'th vertex (edges are represented by the index of 
the other vertex incident to that edge). 
<P>This representation is much more difficult to code, especially if the number 
of edges incident to each vertex is not bounded, so the lists must be linked 
lists (or dynamically allocated). Debugging this is difficult, as following 
linked lists is more difficult. However, this representation uses about as much 
memory as the edge list. Finding the vertices adjacent to each node is very 
cheap in this structure, but checking if two vertices are adjacent requires 
checking all the edges adjacent to one of the vertices. Adding an edge is easy, 
but deleting an edge is difficult, if the locations of the edge in the 
appropriate lists are not known. 
<P>Extend this representation to handle weighted graphs by maintaining both the 
weight and the other incident vertex for each edge instead of just the other 
incident vertex. Multigraphs are already representable. Directed graphs are also 
easily handled by this representation, in one of several ways: store only the 
edges in one direction, keep a seperate list of incoming and outgoing arcs, or 
denote the direction of each arc in the list. 
<H5>Example</H5>The adjacency list representation of the example undirected 
graph is as follows: 
<CENTER>
<TABLE border=1>
  <TBODY>
  <TR>
    <TD align=middle>&nbsp;</TD>
    <TD align=middle>Adjacent</TD></TR>
  <TR>
    <TD align=middle>Vertex</TD>
    <TD align=middle>Vertices</TD></TR>
  <TR>
    <TD align=middle>1</TD>
    <TD align=middle>3, 6</TD></TR>
  <TR>
    <TD align=middle>2</TD>
    <TD align=middle>5</TD></TR>
  <TR>
    <TD align=middle>3</TD>
    <TD align=middle>6, 4, 1</TD></TR>
  <TR>
    <TD align=middle>4</TD>
    <TD align=middle>3</TD></TR>
  <TR>
    <TD align=middle>5</TD>
    <TD align=middle>2</TD></TR>
  <TR>
    <TD align=middle>6</TD>
    <TD align=middle>3, 1</TD></TR></TBODY></TABLE></CENTER>
<H5>Implicit Representation</H5>
<P>For some graphs, the graph itself does not have to be stored at all. For 
example, for the Knight moves and Overfencing problems, it is easy to calculate 
the neighbors of a vertex, check adjacency, and determine all the edges without 
actually storing that information, thus, there is no reason to actually store 
that information; the graph is implicit in the data itself. 
<P>If it is possible to store the graph in this format, it is generally the 
correct thing to do, as it saves a lot on storage and reduces the complexity of 
your code, making it easy to both write and debug. 
<P>If N is the number of vertices, M the number of edges, and <I>d 
<SUB>max</SUB></I> the maximum degree of a node, the following table summarizes 
the differences between the representations: 
<CENTER>
<TABLE border=1>
  <TBODY>
  <TR>
    <TD>Efficiency</TD>
    <TD align=middle>Edge List</TD>
    <TD align=middle>Adj Matrix</TD>
    <TD align=middle>Adj List</TD></TR>
  <TR>
    <TD>Space</TD>
    <TD align=middle>2xM</TD>
    <TD align=middle>N<SUP>2</SUP></TD>
    <TD align=middle>2xM</TD></TR>
  <TR>
    <TD>Adjacency Check</TD>
    <TD align=middle>M</TD>
    <TD align=middle>1</TD>
    <TD align=middle><I>d <SUB>max</SUB></I></TD></TR>
  <TR>
    <TD>List of Adj Vertices</TD>
    <TD align=middle>M</TD>
    <TD align=middle>N</TD>
    <TD align=middle><I>d <SUB>max</SUB></I></TD></TR>
  <TR>
    <TD>Add Edge</TD>
    <TD align=middle>1</TD>
    <TD align=middle>1</TD>
    <TD align=middle>1</TD></TR>
  <TR>
    <TD>Delete Edge</TD>
    <TD align=middle>M</TD>
    <TD align=middle>2</TD>
    <TD align=middle>2x<I>d <SUB>max</SUB></I></TD></TR></TBODY></TABLE></CENTER>
<H4>Connectedness</H4>
<P>An undirected graph is said to be <I>connected</I> if there is a path from 
every vertex to every other vertex. The example graph is <I>not</I> connected, 
as there is no path from vertex 2 to vertex 4. <BR><IMG 
src="Graph Theory.files/graph1.gif"><BR>However, if you add an edge between 
vertex 5 and vertex 6, then the graph becomes connected. <BR><IMG 
src="Graph Theory.files/graph1a.gif"><BR>
<P>A <I>component</I> of a graph is a maximal subset of the vertices such that 
every vertex is reachable from each other vertex in the component. The original 
example graph has two components: {1, 3, 4, 6} and {2, 5}. Note that {1, 3, 4} 
is not a component, as it is not maximal. 
<P>A directed graph is said to be <I>strongly connected</I> if there is a path 
from every vertex to every other vertex. 
<P>A <I>strongly connected component</I> of a directed graph is a vertex u and 
the collection of all vertices v such that there is a path from u to v and a 
path from v to u. 
<H4>Subgraphs</H4>
<P>Graph G' = (V', E') is a subgraph of G = (V, E) if V' is a subset of V and E' 
is a subset of E. 
<P>The subgraph of G <I>induced</I> by V' is the graph (V', E'), where E' 
consists of all the edges of E that are between members of V'. 
<P>For example, for V' = {1, 3, 4, 2}, the subgraph induced is: <BR><IMG 
src="Graph Theory.files/graph4.gif"><BR>
<H4>Special Graphs</H4>
<P>An undirected graph is said to be a <I>tree</I> if it contains no cycles and 
is connected. <BR><IMG src="Graph Theory.files/graph5.gif"><BR>
<P>Many trees are what is called <I>rooted</I>, where there is a notion of the 
"top" node, which is called the <I>root</I>. Thus, each node has one 
<I>parent</I>, which is the adjacent node which is closer to the root, and may 
have any number of <I>children</I>, which are the rest of the nodes adjacent to 
it. The tree above was drawn as a rooted tree. 
<P>An undirected graph which contains no cycles is called a <I>forest</I>. 
<BR><IMG src="Graph Theory.files/graph6.gif"><BR>
<P>A directed acyclic graph is often referred to as a <I>dag</I>. 
<P>A graph is said to be <I>complete</I> if there is an edge between every pair 
of vertices. <BR><IMG src="Graph Theory.files/graph7.gif"><BR>
<P>A graph is said to be <I>bipartite</I> if the vertices can be split into two 
sets <I>V <SUB>1</SUB></I> and <I>V <SUB>2</SUB></I> such there are no edges 
between two vertices of <I>V <SUB>1</SUB></I> or two vertices of <I>V 
<SUB>2</SUB></I>. <BR><IMG 
src="Graph Theory.files/graph8.gif"><BR></TD></TR></TABLE>
<CENTER><A href="http://ace.delos.com/usacogate?a=n8UCMGSrVkI">USACO Gateway</A> 
| <A href="mailto:kolstad@ace.delos.com">Comment or Question</A> 
</CENTER></BODY></HTML>
