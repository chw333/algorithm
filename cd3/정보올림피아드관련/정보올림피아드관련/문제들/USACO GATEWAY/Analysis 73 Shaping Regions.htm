<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0058)http://ace.delos.com/usacoanal/s=1.2.1.1/a=n8UCMGSrVkI/73a -->
<HTML><HEAD><TITLE>Analysis 73: Shaping Regions</TITLE>
<META http-equiv=Content-Type content="text/html; charset=iso-8859-1">
<META content="MSHTML 6.00.2716.2200" name=GENERATOR></HEAD>
<BODY background="Analysis 73 Shaping Regions.files/bg3.jpg"><IMG height=118 
src="Analysis 73 Shaping Regions.files/cow1.jpg" width=742> 
<CENTER><B><FONT size=7>Shaping Regions</FONT></B><BR>Russ Cox </CENTER>
<P><I>Russ's solution is written for a smaller version of the problem.</I> 
<P>Since the grid is small enough (only 640,000 squares at most), we can just 
use an array of characters, plot everything, and then count colors. 
<P>We use color numbers 0..99 rather than 1..100, making white be 0 rather than 
1. Since the "paper" array starts out all zeros, it starts out all white. 
<P>[more comments below after the program] <PRE>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;

#define MAXDIM 800
#define MAXN 100
#define MAXCOLOR 100

char paper[MAXDIM][MAXDIM];

void
main(void)
{
	FILE *fin, *fout;
	int i, n, minx, miny, maxx, maxy, c, x, y;
	int wid, ht;
	int count[MAXCOLOR];

	fin = fopen("rect1.in", "r");
	fout = fopen("rect1.out", "w");
	assert(fin != NULL &amp;&amp; fout != NULL);

	fscanf(fin, "%d %d %d", &amp;wid, &amp;ht, &amp;n);
	for(i=0; i&lt;n; i++) {
		/* read, fill rectangle */
		fscanf(fin, "%d %d %d %d %d", &amp;minx, &amp;miny, &amp;maxx, &amp;maxy, &amp;c);
	
		for(x=minx; x&lt;maxx; x++)
		for(y=miny; y&lt;maxy; y++)
			paper[x][y] = c-1;
	}

	/* count rectangle colors */
	for(i=0; i&lt;MAXCOLOR; i++)
		count[i] = 0;

	for(x=0; x&lt;wid; x++)
	for(y=0; y&lt;ht; y++)
		count[paper[x][y]]++;

	/* print counts */
	for(i=0; i&lt;MAXCOLOR; i++)
		if(count[i])
			fprintf(fout, "%d %d\n", i+1, count[i]);

	exit(0);
}
</PRE>
<H3>Further Analysis by Mathijs Vogelzang</H3>
<P>A straightforward approach to this problem would be to make an array which 
represents the table, and then draw all the rectangles on it. In the end, the 
program can just count the colors from the array and output them. Unfortunately, 
the maximum dimensions of this problem are 10,000 x 10,000, which means the 
program uses 100 million integers. That's too much, so we need another approach. 

<P>An approach that does work for such large cases (and it actually is a lot 
faster too) is to keep track of the rectangles, and delete portions of them when 
they are covered by other rectangles. 
<P>Consider this input set: <PRE>0 0 10 10 5
5 0 15 10 10
</PRE>
<P>The program first reads in the first rectangle and puts it in a list. When it 
reads a new rectangle it checks all items in the list if they overlap with the 
new rectangle. This is the case, and then it deletes the old rectangle from the 
list and adds all parts which aren't covered to the list. (So in this case, the 
program would delete the first rectangle, add <TT>0 0 5 10 5</TT> to the list 
and then add the second rectangle to the list). `` 
<P>If you're unlucky, a new rectangle can create lots of new rectangles (when 
the new rectangle entirely fits into another one, the program creates four new 
rectangles which represent the leftover border: <PRE>+--------+      +-+--+--+
|        |      | |2 |  |
|        |      + +--+  |
|  +-+   |  --&gt; | |  |  |
|  +-+   |      |1|  |3 |
|        |      | +--+  |
|        |      | | 4|  |
+--------+      +-+--+--+
</PRE>This is not a problem however, because there can be only 2500 rectangles 
and there is plenty of memory, so rectangles have to be cut very much run out of 
memory. 
<P>Note that with this approach, the only thing that matters is how many 
rectangles there are and how often they overlap. The maximum dimensions can be 
as large as you want, it doesn't matter for the running time. 
<H3>Further Analysis by Tomek Czajka</H3>
<P>There is another solution to this problem, which runs in O(n*n*log n) time, 
but is quite tricky. First, we add one big white rectangle at the bottom - the 
paper. Then we make two arrays: one containing all vertical edges of the 
rectangles, and the other the horizontal ones. For each edge we have its 
coordinates and remember, whether it's the left or right edge (top or bottom). 
We sort these edges from left to right and from top to bottom. Then we go from 
left to right (sweep), jumping to every x-coordinate of vertical edges. At each 
step we update the set of rectangles seen. We also want to update the amount of 
each color seen so far. So for each x we go from top to bottom, for each y 
updating the set of rectagles at a point (in the structure described below) and 
choosing the top one, so that we can update the amounts of colors seen. 
<P>The structure to hold the set of rectangles at a point should allow adding a 
rectangle (number from 1..1000), deleting a rectangle, and finding the top one. 
We can implement these operations in O(log n) time if we use a heap. To make 
adding and deleting run in O(log n) we must also have for each rectangle its 
position in the heap. 
<P>So the total time spent at each point is O(log n). Thus the algorithm works 
in O(n*n*log n) time. 
<H3>And a solution from mrsigma: <PRE>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

FILE *fp,*fo;

struct rect
{
    int c;
    int x1,y1,x2,y2;
};

int c[2501];
rect r[10001];

int intersect(rect a,const rect &amp;b,rect out[4])
{
    /* do they at all intersect? */
    if(b.x2&lt;a.x1||b.x1&gt;=a.x2)
        return 0;
    if(b.y2&lt;a.y1||b.y1&gt;=a.y2)
            return 0;
    /* they do */

    rect t;

    if(b.x1&lt;=a.x1&amp;&amp;b.x2&gt;=a.x2&amp;&amp;b.y1&lt;=a.y1&amp;&amp;b.y2&gt;=a.y2)
            return -1;

    /* cutting `a' down to match b */
    int nout=0;
    if(b.x1&gt;=a.x1) {
        t=a,t.x2=b.x1;
        if(t.x1!=t.x2)
            out[nout++]=t;
        a.x1=b.x1;
    }
    if(b.x2&lt;a.x2) {
        t=a,t.x1=b.x2;
        if(t.x1!=t.x2)
            out[nout++]=t;
        a.x2=b.x2;
    }
    if(b.y1&gt;=a.y1) {
        t=a,t.y2=b.y1;
        if(t.y1!=t.y2)
            out[nout++]=t;
        a.y1=b.y1;
    }
    if(b.y2&lt;a.y2) {
        t=a,t.y1=b.y2;
        if(t.y1!=t.y2)
            out[nout++]=t;
        a.y2=b.y2;
    }
    return nout;
}

int main(void) {
    fp=fopen("rect1.in","rt");
    fo=fopen("rect1.out","wt");

    int a,b,n;
    fscanf(fp,"%d %d %d",&amp;a,&amp;b,&amp;n);

    r[0].c=1;
    r[0].x1=r[0].y1=0;
    r[0].x2=a;
    r[0].y2=b;

    rect t[4];

    int i,j,rr=1;
    for(i=0;i&lt;n;i++) {
        int tmp;
        fscanf(fp,"%d %d %d %d %d",&amp;r[rr].x1,&amp;r[rr].y1,&amp;r[rr].x2,&amp;r[rr].y2,&amp;r[rr].c);

        if(r[rr].x1&gt;r[rr].x2) {
            tmp=r[rr].x1;
            r[rr].x1=r[rr].x2;
            r[rr].x2=tmp;
        }
        if(r[rr].y1&gt;r[rr].y2) {
            tmp=r[rr].y1;
            r[rr].y1=r[rr].y2;
            r[rr].y2=tmp;
        }

        int nr=rr;
        rect curr=r[rr++];
        for(j=0;j&lt;nr;j++) {
            int n=intersect(r[j],curr,t);
            if(!n)
                continue;
            if(n==-1) {
                memmove(r+j,r+j+1,sizeof(rect)*(rr-j-1));
                j--;
                rr--;
                nr--;
                continue;
            }
            r[j]=t[--n];
            for(;n--&gt;0;)
                r[rr++]=t[n];
        }
    }

    for(i=0;i&lt;rr;i++)
        c[r[i].c]+=(r[i].x2-r[i].x1)*(r[i].y2-r[i].y1);

    for(i=1;i&lt;=2500;i++)
        if(c[i])
            fprintf(fo,"%d %d\n",i,c[i]);

    return 0;
}
</PRE>
<CENTER><A href="http://ace.delos.com/usacogate?a=n8UCMGSrVkI">USACO Gateway</A> 
| <A href="mailto:kolstad@ace.delos.com">Comment or Question</A> 
</CENTER></H3></BODY></HTML>
