<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0057)http://ace.delos.com/usacotext/s=1.2.2.0/a=n8UCMGSrVkI/dp -->
<HTML><HEAD><TITLE>Dynamic Programming</TITLE>
<META http-equiv=Content-Type content="text/html; charset=iso-8859-1">
<META content="MSHTML 6.00.2716.2200" name=GENERATOR></HEAD>
<BODY background="Dynamic Programming.files/bg3.jpg"><IMG height=118 
src="Dynamic Programming.files/cow1.jpg" width=742> 
<CENTER><B><FONT size=4>Dynamic Programming</FONT></B></CENTER>
<H4>Introduction </H4>
<P>Dynamic programming is a confusing name for a programming technique that 
dramatically reduces the runtime of algorithms: from exponential to polynomial. 
The basic idea is to try to avoid solving the same problem or subproblem twice. 
Here is a problem to demonstrate its power: 
<P>Given a sequence of as many as 10,000 integers (0 &lt; integer &lt; 100,000), 
what is the maximum decreasing subsequence? Note that the subsequence does not 
have to be consecutive. 
<H4>Recursive Descent Solution</H4>
<P>The obvious approach to solving the problem is recursive descent. One need 
only find the recurrence and a terminal condition. Consider the following 
solution: <BR><TT><FONT 
size=2><BR>&nbsp;1&nbsp;#include&nbsp;&lt;stdio.h&gt;<BR><BR><BR>&nbsp;2&nbsp;&nbsp;long&nbsp;n,&nbsp;sequence[10000];<BR>&nbsp;3&nbsp;&nbsp;main&nbsp;()&nbsp;{<BR>&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FILE&nbsp;*in,&nbsp;*out;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;in&nbsp;=&nbsp;fopen&nbsp;("input.txt",&nbsp;"r");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out&nbsp;=&nbsp;fopen&nbsp;("output.txt",&nbsp;"w");&nbsp;&nbsp;&nbsp;<BR>&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fscanf(in,&nbsp;"%ld",&nbsp;&amp;n);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;n;&nbsp;i++)&nbsp;fscanf(in,&nbsp;"%ld",&nbsp;&amp;sequence[i]);<BR>10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf&nbsp;(out,&nbsp;"%d\n",&nbsp;check&nbsp;(0,&nbsp;0,&nbsp;99999));<BR>11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit&nbsp;(0);<BR>12&nbsp;&nbsp;}<BR><BR><BR>13&nbsp;&nbsp;check&nbsp;(start,&nbsp;nmatches,&nbsp;smallest)&nbsp;{<BR>14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;better,&nbsp;i,&nbsp;best=nmatches;<BR>15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i&nbsp;=&nbsp;start;&nbsp;i&nbsp;&lt;&nbsp;n;&nbsp;i++)&nbsp;{<BR>16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(sequence[i]&nbsp;&lt;&nbsp;smallest)&nbsp;{<BR>17&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;better&nbsp;=&nbsp;check&nbsp;(i,&nbsp;nmatches+1,&nbsp;sequence[i]);<BR>18&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(better&nbsp;&gt;&nbsp;best)&nbsp;best&nbsp;=&nbsp;better;<BR>19&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>21&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;best;<BR>22&nbsp;&nbsp;}<BR></FONT></TT>
<P>Lines 1-9 and and 11-12 are arguably boilerplate. They set up some standard 
variables and grab the input. The magic is in line 10 and the recursive routine 
`check'. The `check' routine knows where it should start searching for smaller 
integers, the length of the longest sequence so far, and the smallest integer so 
far. At the cost of an extra call, it terminates `automatically' when `start' is 
no longer within proper range. The `check' routine is simplicity itself. It 
traverses along the list looking for a smaller integer than the `smallest' so 
far. If found, `check' calls itself recursively to find more. 
<P>The problem with the recursive solution is the runtime: <BR><TT><FONT 
size=2><BR>&nbsp;&nbsp;N&nbsp;&nbsp;&nbsp;Seconds<BR>&nbsp;&nbsp;60&nbsp;&nbsp;&nbsp;0.130<BR>&nbsp;&nbsp;70&nbsp;&nbsp;&nbsp;0.360<BR>&nbsp;&nbsp;80&nbsp;&nbsp;&nbsp;2.390<BR>&nbsp;&nbsp;90&nbsp;&nbsp;13.190<BR></FONT></TT>
<P>Since the particular problem of interest suggests that the maximum length of 
the sequence might approach six digits, this solution is of limited interest. 
<H5>Starting At The End</H5>
<P>When solutions don't work by approaching them `forwards' or `from the front', 
it is often fruitful to approach the problem backward. In this case, that means 
looking at the end of the sequence first. 
<P>Additionally, it is often fruitful to trade a bit of storage for execution 
efficiency. Another program might work from the end of the sequence, keeping 
track of the longest descending (sub-)sequence so far in an auxiliary variable. 
<P>Consider the sequence starting at the end, of length 1. Any sequence of 
length 1 meets all the criteria for a longest sequence. Notate the `bestsofar' 
array as `1' for this case. 
<P>Consider the last two elements of the sequence. If the the penultimate number 
is larger than the last one, then the `bestsofar' is 2 (which is 1 + `bestsofar' 
for the last number). Otherwise, it's `1'. 
<P>Consider any element prior to the last two. Any time it's larger than an 
element closer to the end, its `bestsofar' element becomes at least one larger 
than that of the smaller element that was found. Upon termination, the largest 
of the `bestsofar's is the length of the longest descending subsequence. 
<P>This is fairly clearly an O(<I>N</I> <SUP>2</SUP>) algorithm. Check out its 
code: <BR><TT><FONT 
size=2><BR>&nbsp;1&nbsp;&nbsp;#include&nbsp;&lt;stdio.h&gt;<BR>&nbsp;2&nbsp;&nbsp;#define&nbsp;MAXN&nbsp;10000<BR>&nbsp;3&nbsp;&nbsp;main&nbsp;()&nbsp;{<BR>&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;num[MAXN],&nbsp;bestsofar[MAXN];<BR>&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FILE&nbsp;*in,&nbsp;*out;<BR>&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;n,&nbsp;i,&nbsp;j,&nbsp;longest&nbsp;=&nbsp;0;<BR>&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;in&nbsp;=&nbsp;fopen&nbsp;("input.txt",&nbsp;"r");<BR>&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out&nbsp;=&nbsp;fopen&nbsp;("output.txt",&nbsp;"w");<BR>&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fscanf(in,&nbsp;"%ld",&nbsp;&amp;n);<BR>10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;n;&nbsp;i++)&nbsp;fscanf(in,&nbsp;"%ld",&nbsp;&amp;num[i]);<BR>11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bestsofar[n-1]&nbsp;=&nbsp;1;<BR>12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i&nbsp;=&nbsp;n-1-1;&nbsp;i&nbsp;&gt;=&nbsp;0;&nbsp;i--)&nbsp;{<BR>13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bestsofar[i]&nbsp;=&nbsp;1;<BR>14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(j&nbsp;=&nbsp;i+1;&nbsp;j&nbsp;&lt;&nbsp;n;&nbsp;j++)&nbsp;{<BR>15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(num[j]&nbsp;&lt;&nbsp;num[i]&nbsp;&amp;&amp;&nbsp;bestsofar[j]&nbsp;&gt;=&nbsp;bestsofar[i])&nbsp;&nbsp;{<BR>16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bestsofar[i]&nbsp;=&nbsp;bestsofar[j]&nbsp;+&nbsp;1;<BR>17&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(bestsofar[i]&nbsp;&gt;&nbsp;longest)&nbsp;longest&nbsp;=&nbsp;bestsofar[i];<BR>18&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>19&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>21&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(out,&nbsp;"bestsofar&nbsp;is&nbsp;%d\n",&nbsp;longest);<BR>22&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(0);<BR>23&nbsp;&nbsp;}<BR></FONT></TT>
<P>Again, lines 1-10 are boilerplate. Line 11 sets up the end condition. Lines 
12-20 run the O(<I>N</I> <SUP>2</SUP>) algorithm in a fairly straightforward way 
with the `i' loop counting backwards and the `j' loop counting forwards. One 
line longer then before, the runtime figures show better performance: 
<BR><TT><FONT 
size=2><BR>&nbsp;&nbsp;&nbsp;N&nbsp;&nbsp;&nbsp;&nbsp;Secs<BR>&nbsp;1000&nbsp;&nbsp;0.080<BR>&nbsp;2000&nbsp;&nbsp;0.240<BR>&nbsp;3000&nbsp;&nbsp;0.550<BR>&nbsp;4000&nbsp;&nbsp;0.950<BR>&nbsp;5000&nbsp;&nbsp;1.450<BR>&nbsp;6000&nbsp;&nbsp;2.080<BR>&nbsp;7000&nbsp;&nbsp;2.990<BR>&nbsp;8000&nbsp;&nbsp;3.700<BR>&nbsp;9000&nbsp;&nbsp;4.700<BR>10000&nbsp;&nbsp;6.330<BR>11000&nbsp;&nbsp;7.350<BR></FONT></TT>The 
algorithm still runs too slow (for competitions) at N=9000. 
<P>That inner loop (``search for any smaller number'') begs to have some storage 
traded for it. 
<P>A different set of values might best be stored in the auxiliary array. 
Implement an array `bestrun' whose index is the length of a long subsequence and 
whose value is the first (and, as it turns out, `best') integer that heads that 
subsequence. Encountering an integer larger than one of the values in this array 
means that a new, longer sequence can potentially be created. The new integer 
might be a new `best head of sequence', or it might not. Consider this sequence: 
<BR><TT><FONT 
size=2><BR>&nbsp;&nbsp;&nbsp;10&nbsp;8&nbsp;9&nbsp;4&nbsp;6&nbsp;3<BR></FONT></TT>Scanning 
from right to left (backward to front), the `bestrun' array has but a single 
element after encountering the 3: <BR><TT><FONT 
size=2><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0:3<BR></FONT></TT>Continuing the 
scan, the `6' is larger than the `3', to the `bestrun' array grows: 
<BR><TT><FONT 
size=2><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0:3<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1:6<BR></FONT></TT>The 
`4' is not larger than the `6', though it is larger than the `3', so the 
`bestrun' array changes: <BR><TT><FONT 
size=2><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0:3<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1:4<BR></FONT></TT>The 
`9' extends the array: <BR><TT><FONT 
size=2><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0:3<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1:4<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2:9<BR></FONT></TT>The 
`8' changes the array similar to the earlier case with the `4': <BR><TT><FONT 
size=2><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0:3<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1:4<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2:8<BR></FONT></TT>The 
`10' extends the array again: <BR><TT><FONT 
size=2><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0:3<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1:4<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2:8<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3:10<BR></FONT></TT>and 
yields the answer: 4 (four elements in the array). 
<P>Because the `bestrun' array probably grows much less quickly than the length 
of the processed sequence, this algorithm probabalistically runs much faster 
than the previous one. In practice, the speedup is large. Here's a coding of 
this algorithm: <BR><TT><FONT 
size=2><BR>&nbsp;1&nbsp;&nbsp;#include&nbsp;&lt;stdio.h&gt;<BR>&nbsp;2&nbsp;&nbsp;#define&nbsp;MAXN&nbsp;200000<BR>&nbsp;3&nbsp;&nbsp;main&nbsp;()&nbsp;{<BR>&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FILE&nbsp;*in,&nbsp;*out;<BR>&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;num[MAXN],&nbsp;bestrun[MAXN];<BR>&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;n,&nbsp;i,&nbsp;j,&nbsp;highestrun&nbsp;=&nbsp;0;<BR>&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;in&nbsp;=&nbsp;fopen&nbsp;("input.txt",&nbsp;"r");<BR>&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out&nbsp;=&nbsp;fopen&nbsp;("output.txt",&nbsp;"w");<BR>&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fscanf(in,&nbsp;"%ld",&nbsp;&amp;n);<BR>10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;n;&nbsp;i++)&nbsp;fscanf(in,&nbsp;"%ld",&nbsp;&amp;num[i]);<BR>11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bestrun[0]&nbsp;=&nbsp;num[n-1];<BR>12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;highestrun&nbsp;=&nbsp;1;<BR>13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i&nbsp;=&nbsp;n-1-1;&nbsp;i&nbsp;&gt;=&nbsp;0;&nbsp;i--)&nbsp;{<BR>14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(num[i]&nbsp;&lt;&nbsp;bestrun[0])&nbsp;{<BR>15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bestrun[0]&nbsp;=&nbsp;num[i];<BR>16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<BR>17&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>18&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(j&nbsp;=&nbsp;highestrun&nbsp;-&nbsp;1;&nbsp;j&nbsp;&gt;=&nbsp;0;&nbsp;j--)&nbsp;{<BR>19&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(num[i]&nbsp;&gt;&nbsp;bestrun[j])&nbsp;{<BR>20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(j&nbsp;==&nbsp;highestrun&nbsp;-&nbsp;1&nbsp;||&nbsp;num[i]&nbsp;&lt;&nbsp;bestrun[j+1]){<BR>21&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bestrun[++j]&nbsp;=&nbsp;num[i];<BR>22&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(j&nbsp;==&nbsp;highestrun)&nbsp;highestrun++;<BR>23&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>24&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>25&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>26&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>27&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>28&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("best&nbsp;is&nbsp;%d\n",&nbsp;highestrun);<BR>29&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(0);<BR>30&nbsp;&nbsp;}<BR></FONT></TT>
<P>Again, lines 1-10 are boilerplate. Lines 11-12 are initialization. Lines 
14-17 are an optimization for a new `smallest' element. They could have been 
moved after line 26. Mostly, these lines only effect the `worst' case of the 
algorithm when the input is sorted `badly'. 
<P>Lines 18-26 are the meat that searches the bestrun list and contain all the 
exceptions and tricky cases (bigger than first element? insert in middle? extend 
the array?). You should try to code this right now - without memorizing it. 
<P>The speeds are impressive. The table below compares this algorithm with the 
previous one, showing this algorithm worked for N well into five digits: 
<BR><TT><FONT 
size=2><BR>&nbsp;&nbsp;N&nbsp;&nbsp;&nbsp;&nbsp;orig&nbsp;&nbsp;&nbsp;&nbsp;Improved<BR>&nbsp;1000&nbsp;&nbsp;0.080&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.030<BR>&nbsp;2000&nbsp;&nbsp;0.240&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.030<BR>&nbsp;3000&nbsp;&nbsp;0.550&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.050<BR>&nbsp;4000&nbsp;&nbsp;0.950&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.060<BR>&nbsp;5000&nbsp;&nbsp;1.450&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.080<BR>&nbsp;6000&nbsp;&nbsp;2.080&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.090<BR>&nbsp;7000&nbsp;&nbsp;2.990&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.110<BR>&nbsp;8000&nbsp;&nbsp;3.700&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.130<BR>&nbsp;9000&nbsp;&nbsp;4.700&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.140<BR>10000&nbsp;&nbsp;6.330&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.160<BR>11000&nbsp;&nbsp;7.350&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.170<BR>20000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.290<BR>40000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.570<BR>60000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.910<BR>80000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.290<BR>100000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.220<BR></FONT></TT>
<P>Marcin Mika points out that you can simplify this algorithm to this tiny 
little solution: <PRE>#include &lt;stdio.h&gt;
#define SIZE 200000
#define MAX(x,y) ((x)&gt;(y)?(x):(y))

int     best[SIZE];        // best[] holds values of the optimal sub-sequence

int 
main (void) {
    FILE *in  = fopen ("input.txt", "r");
    FILE *out = fopen ("output.txt", "w");
    int     i, n, k, x, sol = -1;

    fscanf (in, "%d", &amp;n);	// N = how many integers to read in
    for (i = 0; i &lt; n; i++) {
	best[i] = -1;
	fscanf (in, "%d", &amp;x);
	for (k = 0; best[k] &gt; x; k++)
	    ;
	best[k] = x;
	sol = MAX (sol, k + 1);
    }
    printf ("best is %d\n", sol);
    return 0;
}
</PRE>
<P><I>Not to be outdone, Tyler Lu points out:</I> 
<P>The solutions that currently exist use a linear search to find the 
appropriate location in the 'bestrun' array to insert an integer. However, 
because the auxiliary array is sorted, we may use binary search (O(log N)) so 
that for larger sequences, our runtime is decreased. Here is a solution that 
modifies the previous code: <PRE>#include &lt;stdio.h&gt;
#define SIZE 200000
#define MAX(x,y) ((x)&gt;(y)?(x):(y))

int     best[SIZE];        // best[] holds values of the optimal sub-sequence

int
main (void) {
    FILE *in  = fopen ("input.txt", "r");
    int i, n, k, x, sol;
    int low, high;

    fscanf (in, "%d", &amp;n);	// N = how many integers to read in
    // read in the first integer
    fscanf (in, "%d", &amp;best[0]);
    sol = 1;
    for (i = 1; i &lt; n; i++) {
        best[i] = -1;
    	  fscanf (in, "%d", &amp;x);

        if(x &gt;= best[0]) {
          k = 0;
          best[0] = x;
        }
        else {
          // use binary search instead
          low = 0;
          high = sol-1;
          for(;;) {
            k = (int) (low + high) / 2;
            // go lower in the array
            if(x &gt; best[k] &amp;&amp; x &gt; best[k-1]) {
              high = k - 1;
              continue;
            }
            // go higher in the array
            if(x &lt; best[k] &amp;&amp; x &lt; best[k+1]) {
              low = k + 1;
              continue;
            }
            // check if right spot
            if(x &gt; best[k] &amp;&amp; x &lt; best[k-1])
              best[k] = x;
            if(x &lt; best[k] &amp;&amp; x &gt; best[k+1])
              best[++k] = x;
            break;
          }
        }
	      sol = MAX (sol, k + 1);
    }
    printf ("best is %d\n", sol);
    fclose(in);
    return 0;
}
</PRE>
<H4>Summary</H4>
<P>These programs demonstrate the main concept behind dynamic programming: build 
larger solutions based on previously found solutions. This building-up of 
solutions often yields programs that run very quickly. 
<P>For the previous programming challenge, the main subproblem was: Find the 
largest decreasing subsequence (and its first value) for numbers to the `right' 
of a given element. 
<P>Note that this sort of approach solves a class of problems that might be 
denoted ``one-dimensional''. 
<H4>Two Dimensional DP</H4>
<P>It is possible to create higher dimension problems such as: 
<P>Given two sequences of integers, what is the longest sequence which is a 
subsequence of both sequences? 
<P>Here, the subproblems are the longest common subsequence of smaller sequences 
(where the sequences are the tails of the original subsequences). First, if one 
of the sequences contains only one element, the solution is trivial (either the 
element is in the other sequence or it isn't). 
<P>Look at the problem of finding the longest common subsequence of the last i 
elements of the first sequence and the last j elements of the second sequences. 
There are only two possibilities. The first element of the first tail might be 
in the longest common subsequence or it might not. The longest common sequence 
not containing the first element of the first tail is merely the longest common 
subsequence of the last i-1 elements of the first sequence and the last j 
elements of the second subsequence. The other possibility results from some 
element in the tail of the second sequence matching the first element in tail of 
the first, and finding the longest common subsequence of the elements after 
those matched elements. <BR><IMG src="Dynamic Programming.files/dp1.gif"><BR>
<H5>Pseudocode</H5>
<P>Here's the pseudocode for this algorithm: <BR><TT><FONT 
size=2><BR>&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;the&nbsp;tail&nbsp;of&nbsp;the&nbsp;second&nbsp;sequence&nbsp;is&nbsp;empty<BR>&nbsp;1&nbsp;&nbsp;&nbsp;for&nbsp;element&nbsp;=&nbsp;1&nbsp;to&nbsp;length1<BR>&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;length[element,&nbsp;length2+1]&nbsp;=&nbsp;0<BR><BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;the&nbsp;tail&nbsp;of&nbsp;the&nbsp;first&nbsp;sequence&nbsp;has&nbsp;one&nbsp;element<BR>&nbsp;3&nbsp;&nbsp;&nbsp;matchelem&nbsp;=&nbsp;0<BR>&nbsp;4&nbsp;&nbsp;&nbsp;for&nbsp;element&nbsp;=&nbsp;length2&nbsp;to&nbsp;1<BR>&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;list1[length1]&nbsp;=&nbsp;list2[element]<BR>&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;matchelem&nbsp;=&nbsp;1<BR>&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;matchelem&nbsp;=&nbsp;0&nbsp;then<BR>&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;length[length1,element]&nbsp;=&nbsp;0<BR>&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<BR>10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;length[length1,element]&nbsp;=&nbsp;1<BR><BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;loop&nbsp;over&nbsp;the&nbsp;beginning&nbsp;of&nbsp;the&nbsp;tail&nbsp;of&nbsp;the&nbsp;first&nbsp;sequence<BR>11&nbsp;&nbsp;&nbsp;for&nbsp;loc&nbsp;=&nbsp;length1-1&nbsp;to&nbsp;1<BR>12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;maxlen&nbsp;=&nbsp;0<BR>13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;element&nbsp;=&nbsp;length2&nbsp;to&nbsp;1<BR>&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;longest&nbsp;common&nbsp;subsequence&nbsp;doesn't&nbsp;include&nbsp;first&nbsp;element<BR>14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;length[loc+1,element]&nbsp;&gt;&nbsp;maxlen<BR>15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;maxlen&nbsp;=&nbsp;length[loc+1,element]<BR>&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;longest&nbsp;common&nbsp;subsequence&nbsp;includes&nbsp;first&nbsp;element<BR>16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;list1[loc]&nbsp;=&nbsp;list2[element]&nbsp;<BR>17&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;length[loc+1,element+1]+1&nbsp;&gt;&nbsp;maxlen<BR>18&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;maxlen&nbsp;=&nbsp;length[loc,element+1]&nbsp;+&nbsp;1<BR>19&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;length[loc,element]&nbsp;=&nbsp;maxlen<BR></FONT></TT>
<P>This program runs in O(<I>N</I> x <I>M</I>) time, where <I>N</I> and <I>M</I> 
are the respectively lengths of the sequences. 
<P>Note that this algorithm does not directly calculate the longest common 
subsequence. However, given the length matrix, you can determine the subsequence 
fairly quickly: <BR><TT><FONT 
size=2><BR>&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;location1&nbsp;=&nbsp;1<BR>&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;location2&nbsp;=&nbsp;1<BR><BR><BR>&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(length[location1,location2]&nbsp;!=&nbsp;0)<BR>&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flag&nbsp;=&nbsp;False<BR>&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;element&nbsp;=&nbsp;location2&nbsp;to&nbsp;length2<BR>&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(list1[location1]&nbsp;=&nbsp;list2[element]&nbsp;AND<BR>&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;length[location1+1,element+1]+1&nbsp;=&nbsp;length[location1,location2]<BR>&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output&nbsp;(list1[location1],list2[element])<BR>&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location2&nbsp;=&nbsp;element&nbsp;+&nbsp;1<BR>10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flag&nbsp;=&nbsp;True<BR>11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break&nbsp;for<BR>12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location1&nbsp;=&nbsp;location1&nbsp;+&nbsp;1<BR></FONT></TT>
<P>The trick to dynamic programming is finding the subproblems to solve. 
Sometimes it involves multiple parameters: 
<P>A bitonic sequence is a sequence which increases for the first part and 
decreases for the second part. Find the longest bitonic sequence of a sequence 
of integers (technically, a bitonic can either increase-then-decrease or 
decrease-then-increase, but for this problem, only increase and then decrease 
will be considered). 
<P>In this case, the subproblems are the longest bitonic sequence and the 
longest decreasing sequence of prefixes of the sequence (basically, what's 
longest sequence assuming the turn has not occurred yet, and what's longest 
sequence starting here assuming the turn has already occurred). 
<P>Sometimes the subproblems are well hidden: 
<P>You have just won a contest where the prize is a free vacation in Canada. You 
must travel via air, and the cities are ordered from east to west. In addition, 
according to the rules, you must start at the further city west, travel only 
east until you reach the furthest city east, and then fly only west until you 
reach your starting location. In addition, you may visit no city more than once 
(except the starting city, of course). 
<P>Given the order of the cities, with the flights that can be done (you can 
only fly between certain cities, and just because you can fly from city A to 
city B does not mean you can fly the other direction), calculate the maximum 
number of cities you can visit. 
<P>The obvious item to try to do dynamic programming on is your location and 
your direction, but it's important what path you've taken (since you can't 
revisit cities on the return trip), and the number of paths is too large to be 
able to solve (and store) the result of doing all of those subproblems. 
<P>However, if, instead of trying to find the path as described, it is found a 
different manner, then the number of states greatly decreases. Imagine having 
two travelers who start in the western most city. The travelers take turns 
traveling east, where the next traveler to move is always the western-most, but 
the travelers may never be at the same city, unless it is either the first or 
the last city. However, one of the traveler is only allowed to make "reverse 
flights," where he can travel from city A to city B if and only if there is a 
flight from city <B>B</B> to city <B>A</B>. 
<P>It's not too difficult to see that the paths of the two travelers can be 
combined to create a round-trip, by taking the normal traveler's path to the 
eastern-most city, and then taking the reverse of the other traveler's path back 
to the western-most city. Also, when traveler x is moved, you know that the 
traveler y has not yet visited any city east of traveler x except the city 
traveler y is current at, as otherwise traveler y must have moved once while x 
was west of y. Thus, the two traveler's paths are disjoint. Why this algorithm 
might yield the maximum number of cities is left as an exercise. 
<H4>Recognizing Problems solvable by dynamic programming</H4>
<P>Generally, dynamic programming solutions are applied to those solutions which 
would otherwise be exponential in time, so if the bounds of the problem are too 
large to be able to be done in exponential time for any but a very small set of 
the input cases, look for a dynamic programming solution. Basically, any program 
you were thinking about doing recursive descent on, you should check to see if a 
dynamic programming solution exists if the inputs limits are over 30. 
<H4>Finding the Subproblems</H4>
<P>As mentioned before, finding the subproblems to do dynamic programming over 
is the key. Your goal is to completely describe the state of a solution in a 
small amount of data, such as an integer, a pair of integers, a boolean and an 
integer, etc. 
<P>Almost without fail, the subproblem will be the `tail-end' of a problem. That 
is, there is a way to do the recursive descent such that at each step, you only 
pass a small amount of data. For example, in the air travel one, you could do 
recursive descent to find the complete path, but that means you'd have to pass 
not only your location, but the cities you've visited already (either as a list 
or as a boolean array). That's too much state for dynamic programming to work 
on. However, recursing on the pair of cities as you travel east subject to the 
constant given is a very small amount of data to recurse on. 
<P>If the path is important, you will not be able to do dynamic programming 
unless the paths are <B>very</B> short. However, as in the air travel problem, 
depending on how you look at it, the path may not be important. 
<H4>Sample Problems</H4>
<H5></H5>Polygon Game [1998 IOI]
<H5></H5>
<P>Imagine a regular N-gon. Put numbers on nodes, either and the operators `+' 
or `*' on the edges. The first move is to remove an edge. After that, combine 
(e.g., evaluate the simple term) across edges, replacing the edge and end points 
with node with value equal to value of end point combined by operations, for 
example: <BR><TT><FONT 
size=2><BR>&nbsp;&nbsp;...--&nbsp;3&nbsp;--+--&nbsp;5&nbsp;--*--&nbsp;7&nbsp;--...<BR>&nbsp;&nbsp;...-----&nbsp;8&nbsp;----*-----&nbsp;7&nbsp;--...<BR>&nbsp;&nbsp;...--------&nbsp;56&nbsp;-----------...<BR></FONT></TT>Given 
a labelled N-gon, maximize the final value computed. 
<H5>Subset Sums [Spring 98 USACO]</H5>
<P>For many sets of consecutive integers from 1 through N (1 &lt;= N &lt;= 39), 
one can partition the set into two sets whose sums are identical. For example, 
if N=3, one can partition the set {1, 2, 3} in one way so that the sums of both 
subsets are identical: 
<CENTER>{3} and {1,2} </CENTER>This counts as a single partitioning (i.e., 
reversing the order counts as the same partitioning and thus does not increase 
the count of partitions). 
<P>If N=7, there are 4 ways to partition the set {1, 2, 3, ... 7} so that each 
partition has the same sum: 
<CENTER>{1,6,7} and {2,3,4,5} </CENTER>
<CENTER>{2,5,7} and {1,3,4,6} </CENTER>
<CENTER>{3,4,7} and {1,2,5,6} </CENTER>
<CENTER>{1,2,4,7} and {3,5,6} </CENTER>
<P>Given N, your program should print the number of ways a set containing the 
integers from 1 through N can be partitioned into two sets whose sums are 
identical. Print 0 if there are no such ways. 
<H5>Number Game [IOI 96, maybe]</H5>
<P>Given a sequence of no more than 100 integers (-32000..32000), two opponents 
alternate turns removing the leftmost or rightmost number from a sequence. Each 
player's score at the end of the game is the sum of those numbers he or she 
removed. Given a sequence, determine the maximum winning score for the first 
player, assuming the second player plays optimally. <BR><BR>
<CENTER><A href="mailto:grader@ace.delos.com">Submit Solution via Email</A> 
&nbsp;|&nbsp; <A href="http://ace.delos.com/usacogate?a=n8UCMGSrVkI">USACO 
Gateway </A>&nbsp;| &nbsp; <A href="mailto:kolstad@ace.delos.com">Comment or 
Question </A></CENTER></BODY></HTML>
