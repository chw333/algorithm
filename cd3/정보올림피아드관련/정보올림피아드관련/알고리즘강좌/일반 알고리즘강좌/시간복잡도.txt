알고리즘의 분류 

O(1) 
이런 복잡도를 가지는 알고리즘은 대부분의 명령들이 한번 혹은 단지 몇 번만 실행된다. 
입력의 크기에 상관없이 수행시간이 거의 일정하다. 

O(logn) 
입력의 크기가 커짐에 따라 알고리즘의 수행속도는 매우 서서히 증가한다. 이런 종류의 
빅-오는 큰 문제를 크기가 반으로 줄어든 작은 문제로 변형시켜 해결 가능한 알고리즘에
서 공통적으로 나타나는 복잡도이다. 이진 탐색(binary search)의 경우를 예로 들어보면
, 한번의 비교에 의해서 작은 이진 탐색 문제로 변형된다고 볼 수 있다. 

O(n) 
각 입력에 대하여 적은 양의 명령들이 실행되는 알고리즘의 복잡도. 입력이 증가함에 따
라 비례적으로 수행시간도 늘어난다. n개의 입력을 처리하는 알고리즘은 이보다 더 적은
복잡도를 가질 수 없다. 

O(nlogn) 
이런 종류의 빅-오는 큰 문제를 작은 두 개의 문제로 변형시켜 각각을 해결하고, 작은 
문제의 해를 결합하여 전체 알고리즘의 해를 구하는 알고리즘에서 공통적으로 나타나는
복잡도이다. 입력의 크기가 t배 늘어나는 경우에 실행시간은 t배보다 조금 더 늘어나는
알고리즘이다.
 
O(n2) 
모든 입력 데이터를 반복적으로 처리하는 알고리즘에서 전형적으로 나타난다. 알고리즘
속에 루프가 한 번 중첩되어 나타나는 부분이 있다. 상대적으로 적은 입력에 대해서만 
사용 가능한 알고리즘이다. 

O(n3) 
위와 비슷하게, 모든 입력 데이터를 3번 중첩하여 반복적으로 처리하는 알고리즘에서 
전형적으로 나타난다. 상대적으로 적은 입력에 대해서만 사용 가능하다. 

O(2n) 
이런 종류의 알고리즘을 실제로 사용할 수는 없다. 대신에 Heuristic과 같은 방법을 
사용하여 근사적인 해를 구하는 방법을 많이 사용한다. 