이분 탐색 ( Binary Search ) (1)
                                    - 작성자 : 하재승님
* lg n = log_2 n 입니다.

 안녕하세요.
 정렬을 배우게 되면 가장 먼저 드는 생각이 있습니다. 이걸 왜 쓸까?
겨우 순서대로 나열만 해주는 것 뿐인데 말이죠.
하지만 정렬을 해주게 되면 프로그램이 더 간단해지거나 빨라지는 효과를 가져올 수 있습니
다. 98 KOI 중등부 3번 같은건 정렬 후 다이나믹으로 풀 수 있는 문제죠.

 각설하고 (--a) 정렬하고 나서 얻을 수 있는 장점 중 하나가 배열 안에 어떤 값이 있는지 
없는지 찾을 때 속도가 O(lg n) (단, n은 데이터 개수) 수준으로 만들 수 있다는 거죠.

 다음과 같은 n(=11)개의 숫자로 이루어진 숫자 배열을 생각합시다.
3 20 4 33 15 6 1 17 24 21 55
( C/C++에선 int a[11];   Pascal에 a:array[1..11] of integer; 
  으로 선언되었다고 하죠. n에는 데이터 개수(=11)구요.)

만약 저기에 어떤 값이 어느 위치에 있는지 찾으려고 한다면 (없으면 -1)

in C/C++ :

int find(int x)
{
  int i;
  for(i=0;i<n;i++)
  {
    if ( a[i] == x )
      return i;
  }
  return -1;
}

in PASCAL :

function find(x:integer):integer;
var
  i:integer;
begin
  for i:=1 to n do
  begin
    if a[i]=x then
    begin
      find := i;
      exit;
    end
  end;
  find := -1;
end;

 정도로 할 수 있겠죠.

 이 경우 걸리는 시간은 얼마일까요?
x가 3이었다면 바로 찾게 되니까 시간은 1 정도라 생각할 수 있을꺼고
x가 55이었다면 다 봐야 하니까 11(=n) 이라고 할 수 있죠.
평균적으로는 n/2 정도라 보면 무난할 듯.
O-표기법으로는 O(n)의 시간이 되겠죠.

 n이 물 18g 속의 분자수라 하면 6 × 10^23 정도 되거든요. 이 경우 1GHz = (10^9 Hz) 컴
터에서 한 명령어에 한 개의 물분자를 검색한다 하더라도 6 × 10^14 초(=600000000000000
초) 정도 걸리겠군요. 이 시간이면 1902 5875년이고 지금부터 이 정도 시간동안 100원을 통
장에 넣으면 연이자가 5%라 할때 ... 계산 불가군요 -_- 9로 시작해서 뒤에 0이 403146개 
붙는 돈입니다. 우리나라 예산은 70000000000000정도 밖에 안됩니다. ( 7하고 0이 12개 )

다시 원래대로 돌아가서
3 20 4 33 15 6 1 17 24 21 55
이걸 정렬해 보면 다음과 같습니다.
1 3 4 6 15 17 20 21 24 33 55
(정렬은 퀵소트를 추천합니다. 진짜로 빠릅니다. 개인적으로 간단한 소트 하나 정도는 외우
시는걸 추천하는데 이왕이면 퀵소트를 외우세요.)

이분 탐색 설명을 들어 갑니다. (  )

일단 찾는 숫자를 k라고 해놓죠.

 처음에는 찾는 숫자가 어디에 있을지 모릅니다. 젤 처음에 있을지 젤 마지막에 있을지 어쩌
면 젤루 가운데 있을 수도 있죠. 하지만 역시 모르죠.
만약 우리가 k를 배열의 i번째 요소 ( a[i] ) 랑 비교한다고 생각해 봅시다.
그럼 총 3가지 경우가 있을 수 있겠죠.

k가 a[i] 보다 클 때 :
  배열 a안의 요소들은 정렬 되어있으니까 a[1] < a[2] < a[3] < ... 이겠죠.
  a[i] < k 란 말은
  a[1] < a[2] < ... < a[i] < k를 뜻하게 되니까
  k는 a[1], a[2], ... a[i] 중 어느 것하고도 같지 않겠군요.
  그렇다면 배열 안에서 a[i+1]에서 a[n] 중에 k랑 같은 게 있는지만 검사해 보면
  k 위치를 구할수 있겠네요?

k가 a[i] 보다 작을 때 :
  위와 마찬가지로 하면
  a[1]에서 a[i-1] 사이에 k 랑 같은게 있는지만 검사해 보면 되겠네요.

k가 a[i] 보다 같을 때 : 
  이런 후루가! 바로 어디있는지 찾았군요. 

 정리해봅시다.
a[i]가 k보다 큰지 작은지는 아직 모르지만, a[i]와 k를 비교하고 나면
(1) i+1 ... n
(2) 1 ... i
(3) 바로 끝
의 세가지 경우가 나오는군요.

 검색해야할 범위의 크기가 시간이 얼마나 걸려야 하는지를 좌우하게 되니까 
i+1 ... n 과 1 ... i 크기를 비슷하게 해주면 좋을 것 같군요.
그럴려고 하면 i = n/2 정도로 하면 무난하겠군요. 
n 이 홀수라면 정수부분만 취하면 되겠죠.

 다시 말해 검색의 시작을 가운데의 원소부터 한다는 말이 되겠네요.
여기까지 이해되셨나요?
찾으려는 숫자가 가운데를 기준으로 왼쪽이나 오른쪽이나 있을 확률이 각각 반반이니까 그렇게 한
다고 생각하셔도 되고요. (이게 훨씬 간단한가요 -_-a)

 그렇다면 비교하고 나서 그 다음부턴 어떻게 할까요?
마찬가지로 그 범위 안에서 가운데 값과 비교해 보면 되겠죠. 맞죠?

 예를 듭시다.
1 3 4 6 15 17 20 21 24 33 55
찾으려는 숫자가 21이라고 합시다.
처음에는 11개니까 6번째 걸 보게 되겠군요.
( 좀더 소스에 맞추자면 1~11까지니까 ( 1 + 11 ) / 2 = 6 이군요. )
17 보다 21이 크니까 그 다음 범위는 7 ~ 11 이군요.
( 7 + 11 ) / 2 = 9
24 보다는 21이 작으니까 7~8
( 7 + 8 ) / 2 = 7 (정수부분!)
20이니까 21보다 작군요 8~8
( 8 + 8 ) / 2 = 8
8에서 21을 찾았군요!

 만약 22를 찾는 중이었다면 어떻게 되었을까요?
쭉 동일한 과정이다가 제일 마지막에서
21보다 22가 크니까 범위가 9~8이 되겠군요.

 범위 9~8이라는건 말도 안돼는 범위죠? 즉, 데이터가 없다는걸 뜻합니다. 못찾은거니까 -1 
정도 리턴해 주면 되겠죠.

 소스는 다음 강의에서! 
글 너무 길어지는 듯 -_- 제가 좀 지겹게 글을 쓰지만. 이상으로 들어감돠.

