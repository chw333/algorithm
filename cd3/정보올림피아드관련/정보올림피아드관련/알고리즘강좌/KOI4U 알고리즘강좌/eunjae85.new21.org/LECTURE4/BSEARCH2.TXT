이분 탐색 ( Binary Search ) (2)
* 이분 탐색 (1)과 이어지는 내용입니다.

 그럼 소스를 짜볼까요. 계속 같은 과정 ( 가운데 값과 비교해서 왼쪽과 오른쪽으로 탐색 )을 
반복하니까 일단 재귀로 짤 수 있겠군요.

in C/C++:

int a[10];
int n=10;
int findrec(int l, int r, int k)
{
  if (l<r)
  {
    int m;
    m = (l+r)/2;
    if ( a[m] < k ) return findrec( m+1, r, k);
    else if ( k < a[m] ) return findrec( l, m-1, k);
    else return m; // a[i]==k
  }
  else
  {
    return -1;
  }
}

int find(int k)
{
  return findrec(0, n-1, k);
}

in PASCAL:

const
  n = 10;
var
  a : array[1..10] of integer;

function findrec( l, r, k : integer) : integer;
var
  m:integer;
begin
  if l < r then
  begin
    m := ( l + r ) div 2;
    if a[m] < k then findrec := findrec( m+1, r, k )
    else if k < a[m] then findrec := findrec( l, m-1, k )
    else findrec := m;
  end
  else
    findrec := -1;
end;

function find( k : integer) : integer;
begin
  find := findrec( 1, n, k );
end;

 아직 끝나지 않았습니다. 이 경우 왼쪽 오른쪽 어느 한쪽만 들어가면 되죠. 그렇다면 저런 
형태로 재귀를 쓰는건 낭비라고요. 그리고 비재귀로 짰을 때 별로 복잡하지도 않고요. 그래
서 비재귀로 고쳐보겠습니다. 일단 l, r이 인수니까 루프를 돌면서 l, r 값만 적절히 바꿔주
면 되겠군요.

in C/C++:

int find(int k)
{
  int l, m, r;
  l = 0;
  r = n-1;
  do
  {
    m = ( l + r ) / 2;
    if ( a[m] < k ) 
      l = m+1;
    else if ( k < a[m] ) 
      r = m-1;
    else 
      return m; // a[i]==k
  } while(l<r);
  return -1;
}

in PASCAL:

function find(k:integer):integer;
var
  l, m, r:integer;
begin
  l = 1;
  r = n;
  repeat
    m := ( l + r ) div 2;
    if a[m] < k then
      l := m+1
    else if k < a[m] then
      r = m-1
    else 
    begin
      find := m;
      exit;
    end;
  until (l>=r);
  find := -1;
end;

 간단하죠 -_-? (두 언어로 다쓰니 귀찮군요 --+)

 시간 복잡도 분석을 해봅시다.
크기가 n 일 때 걸리는 시간을 T[n] 이라 하죠.
저번 시간에 3가지로 경우가 나뉘었었죠?
각각 생각해보면
T[n] = 
(1) T[n/2] + 1
(2) T[n/2] + 1
(3) 1
이 되나요?

 최악의 경우를 고려한다면 계속 (1)이나 (2) 다가 제일 마지막에 찾는 거겠죠.
그 경우를 잡아 시간 복잡도를 계산해 보죠.
(단, 2^k <= n < 2^(k+1))

T[n] = T[n/2] + 1
     = (T[n/4] + 1) + 1 = T[ n / 2^2 ] + 2
     = (T[n/8] + 1) + 2 = T[ n / 2^3 ] + 3
     ...
     = T[ n / 2^k ] + k
근데 1 <= n / 2^k < 2 니까 ( 위의 부등식에서 ) 
T[ n / 2^k ]은 거의 1이라 봐도 무난.
T[n] = k + 1 이겠군요.

 좀더 수학적으로 k 값은 log_2 n 이니까
이분 탐색의 시간 복잡도는 O( lg n )입니다.

 log는 아주 느리게 증가하는 함수입니다.
lg n 에다가 아까 대입했던 6 × 10^23을 대입해 보면 78.989 정도 나오는 군요.
79라 보면, 1GHz 컴퓨터에서 0.000000079초 (79ns)걸리는 시간이군요. 아까 처음 설명한 
O(n) 방식과 비교할 때 ( 60000000000000초 ) 많은 차이가 나죠? 그래서 이분 탐색을 사용
합니다. 어떤 값을 찾는 일이 많이 필요하다면 정렬하고 이분 탐색 하는게 더 빠르다는 거
죠. (정렬하는데 어느정도 시간이 걸림에도 불구하고요.)

 이분 검색은 상당히 자주 쓰이니까 외워두시는걸 추천합니다. (뭐든지 외우라는 것처럼 보
이는군요 -_-)

또 최종적으로 정리하자면,
(1) 경우를 나누는 방법
(2) 답을 구하는 재귀적 방법 찾기
(3) 재귀적 방법을 비재귀적으로 바꾸기
(4) 재귀적 함수의 시간 복잡도 계산하기
를 조금씩 언급했군요.
이만요. 빠빠~

ps) 여담인데요 -_- 언어에 있어서 C/C++ 하고 Pascal 하고 파일 입출력 제외하고는 크게 
다른 것 없거덩요. C/C++ 유저님들하고 Pascal 유저님들도 상대 언어를 알아두시는게 공부
하는데 수월하실 겁니다. 어떤 자료를 만나게 될지 모르니까요.
