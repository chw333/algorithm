<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
<head>
<title>동적계획법의 간단한 예</title>
<meta name="generator" content="Namo WebEditor v3.0">
</head>

<body bgcolor="white" text="black" link="blue" vlink="purple" alink="red">

<p style="line-height:130%;">동적계획법의 간단한 예</p>
<p style="line-height:130%;">1. 팩토리얼</p>
<p style="line-height:130%;">5명의 사람 A, B, C, D, E가 있습니다. 이 사람들이 
차례로 한줄로 서는 방법은 모두 몇가지 일까요? 이것을 5개 중에서 순서대로 5개를 
뽑는 순열이라고 하고 5P5라고 씁니다. 이 순열의 수는 5!로 5 * 4 * 3 * 2 * 1입니다.</p>
<p style="line-height:130%;">n!을 n팩토리얼이라고 하고 n! = n * (n-1) * (n-2) 
* ... * 2 * 1로 계산합니다.</p>
<p style="line-height:130%;">만약에 대회에 숫자 n을 입력하면 n!을 계산하는 프로그램을 
작성하시오.. 라는 문제가 나왔다면 쉽게 푸실 수 있을 것입니다. 하지만 아무리 
단순하게 풀었다 하더라도 그 속에는 이미 동적계획법을 사용하고 있다는 사실을 
곧 발견하실 수 있을 것입니다.</p>
<p style="line-height:130%;">일단 이 문제를 동적계획법을 이용해서 차근차근 풀어보도록 
하겠습니다.</p>
<p style="line-height:130%;">1. 문제가 최적화의 원리가 성립하는지 검사(즉 동적 
계획법으로 해결할 수 있는지)</p>
<ul>
    <p style="line-height:130%;">이 문제는 최적화와는 별 관계가 없으니 그냥 
    생략 하도록 합니다.</p>
</ul>
<p style="line-height:130%;">2. 부분문제를 정의한다.</p>
<ul>
    <p style="line-height:130%;">부분문제는 흔히 함수로 정의합니다. 여기서는 
    함수 C를 부분문제 함수로 정의하도록 하겠습니다. C(k)는 1 * 2 * 3 * ... * 
    k라고 정의 하겠습니다.</p>
</ul>
<p style="line-height:130%;">3. 우리가 구해야 하는 큰 문제는 어떻게 정의되는지 
알아본다.</p>
<ul>
    <p style="line-height:130%;">부분문제의 정의에 의해서 우리가 결국 구해야 
    하는 해는 C(N)입니다. 토달것 없죠?</p>
</ul>
<p style="line-height:130%;">4. 큰 문제와 작은 문제간의 관계를 찾는다. 즉, 점화식을 
구한다.</p>
<ul>
    <p style="line-height:130%;">C(k) = 1 * 2 * 3 * ... * (k - 1) * k입니다. 
    이 식은<br>
    C(k) = {1 * 2 * 3 * ... * (k - 1)} * k = C(k - 1) * k<br>
    즉, <font color="red">C(k) = C(k - 1) * k</font>로 나타낼 수 있습니다. 물론 
    다른 식으로도 정의할 수 있지만 여기서는 이 식을 점화식으로 삼도록 하겠습니다.</p>
</ul>
<p style="line-height:130%;">5. 점화식을 통해 작은 문제들을 어떤 순서로 구해 
나갈 것인지를 결정한다.</p>
<ul>
    <p style="line-height:130%;">우리가 구해야 하는 해는 C(N)입니다. C(N)을 
    위에서 정의한 점화식대로 구하기 위해서는 먼저 C(N - 1)을 알아야 하고, C(N 
    - 1)을 알기 위해서는 C(N - 2)를 알아야 하고.... 결국 C(1)을 알아야 합니다. 
    C(1) = 1이라는 것은 아니가 굳이 C(0)을 알 필요는 없지요. 부분문제는 결국 
    C(1) 부터 C(N)까지 차례로 구해야 합니다.</p>
</ul>
<p style="line-height:130%;">6. 답을 얻는 과정을 추적하는 방법을 세워야 한다.</p>
<ul>
    <p style="line-height:130%;">이 문제는 답만 알면 되지 답이 생성되는 과정은 
    필요가 없죠? 그러므로 생략..</p>
</ul>
<p style="line-height:130%;">이 문제를 동적계획법으로 풀면 다음과 같이 됩니다.</p>
<p style="line-height:130%;"><font face="굴림체">Factorial (N)<br>
&nbsp;&nbsp;int Table[100];<br>
&nbsp;&nbsp;int k;<br>
{<br>
&nbsp;&nbsp;Table[1] &lt;- 1;<br>
&nbsp;&nbsp;for k = 2 to N<br>
&nbsp;&nbsp;&nbsp;&nbsp;Table[k] &lt;- Table[k - 1] * k;<br>
&nbsp;&nbsp;result &lt;- Table[N];<br>
}</font></p>
<p style="line-height:130%;">거창하게 설명은 했는데 알고리즘은 굉장히 단순하죠? 
실제 파스칼 소스를 보도록 하겠습니다.</p>
<p style="line-height:130%;"><font face="굴림체">program Factorial_Dynamic;<br>
var<br>
&nbsp;&nbsp;table : array[1..100] of integer;<br>
&nbsp;&nbsp;n, k &nbsp;: integer;<br>
begin<br>
&nbsp;&nbsp;readln (n);</font></p>
<p style="line-height:130%;"><font face="굴림체">&nbsp;&nbsp;table[1] := 1;<br>
&nbsp;&nbsp;for k := 2 to n do<br>
&nbsp;&nbsp;&nbsp;&nbsp;table[k] := table[k - 1] * k;</font></p>
<p style="line-height:130%;"><font face="굴림체">&nbsp;&nbsp;writeln (table[n]);<br>
end.</font></p>
<p style="line-height:130%;">만약 Table[7]을 구하려고 할 때에는 실제로는 그 
전항인 Table[6]만 기억하고 있으면 됩니다. 즉, 나머지 배열 공간은 저장할 필요가 
없다는 뜻으로 이것을 이용하면 메모리를 절약할 수 있습니다. 다음은 기본 알고리즘은 
같지만 배열을 사용하지 않는 소스입니다.</p>
<p style="line-height:130%;"><font face="굴림체">program Factorial_Dynamic_NoTable;</font></p>
<p style="line-height:130%;"><font face="굴림체">var<br>
&nbsp;&nbsp;n, k, result &nbsp;: integer;<br>
begin<br>
&nbsp;&nbsp;readln (n);</font></p>
<p style="line-height:130%;"><font face="굴림체">&nbsp;&nbsp;result := 1;<br>
&nbsp;&nbsp;for k := 2 to n do<br>
&nbsp;&nbsp;&nbsp;&nbsp;result := result * k;</font></p>
<p style="line-height:130%;"><font face="굴림체">&nbsp;&nbsp;writeln (result);<br>
end.</font></p>
<p style="line-height:130%;"><br>
2. 피보나치 수열</p>
<p style="line-height:130%;">피보나치 수열 F의 일반항은 F(1) = 1, F(2) = 1, 
F(n) = F(n - 1) + F(n - 2)로 정의된다. 숫자 n을 입력받아 피보나치 수열 F의 n항을 
수하는 프로그램을 작성하시오.</p>
<p style="line-height:130%;">F = 1 1 2 3 5 8 13 21 34 55 89 144 233 ...</p>
<p style="line-height:130%;">1. 문제가 최적화의 원리가 성립하는지 검사(즉 동적 
계획법으로 해결할 수 있는지)</p>
<ul>
    <p style="line-height:130%;">이것 역시 생략...</p>
</ul>
<p style="line-height:130%;">2. 부분문제를 정의한다.</p>
<ul>
    <p style="line-height:130%;">문제에서 친절하게 제시가 되어 있죠?</p>
</ul>
<p style="line-height:130%;">3. 우리가 구해야 하는 큰 문제는 어떻게 정의되는지 
알아본다.</p>
<ul>
    <p style="line-height:130%;">역시 문제에서 친절하게 제시되어 있음.. F(n)을 
    구하면 됩니다.</p>
</ul>
<p style="line-height:130%;">4. 큰 문제와 작은 문제간의 관계를 찾는다. 즉, 점화식을 
구한다.</p>
<ul>
    <p style="line-height:130%;">친절하게 점화식까지 주어져 있습니다.. -_-;</p>
</ul>
<p style="line-height:130%;">5. 점화식을 통해 작은 문제들을 어떤 순서로 구해 
나갈 것인지를 결정한다.</p>
<ul>
    <p style="line-height:130%;">이 문제 역시 F(1)부터 F(n)까지 차례로 구해 
    나가야 합니다.</p>
</ul>
<p style="line-height:130%;">6. 답을 얻는 과정을 추적하는 방법을 세워야 한다.</p>
<ul>
    <p style="line-height:130%;">필요 없죠?</p>
</ul>
<p style="line-height:130%;">이제 동적계획법을 이용해 문제를 풀기 위한 모든 
준비가 끝났습니다. 프로그램 작성은 매우 간단합니다.</p>
<p style="line-height:130%;"><font face="굴림체">program Fibonacci_Dynamic;</font></p>
<p style="line-height:130%;"><font face="굴림체">var<br>
&nbsp;&nbsp;Table : array[1..100] of integer;<br>
&nbsp;&nbsp;n, k &nbsp;: integer;<br>
begin<br>
&nbsp;&nbsp;readln (n);</font></p>
<p style="line-height:130%;"><font face="굴림체">&nbsp;&nbsp;Table[1] := 1;<br>
&nbsp;&nbsp;Table[2] := 1;</font></p>
<p style="line-height:130%;"><font face="굴림체">&nbsp;&nbsp;for k := 3 to n 
do<br>
&nbsp;&nbsp;&nbsp;&nbsp;Table[k] := Table[k - 1] + Table[k - 2];</font></p>
<p style="line-height:130%;"><font face="굴림체">&nbsp;&nbsp;writeln (Table[n]);<br>
end.</font></p>
<p style="line-height:130%;">팩토리얼 구하는 방법과 크게 다르지 않습니다. 이렇게 
동적계획법은 문제를 잘 분석하고 풀기 위한 준비를 철저히 한다면 그 구현이 매우 
간단하고 신뢰성이 있다는 것이 강점입니다. 위의 피보나치 프로그램도 Table배열을 
사용하지 않고 구할 수 있습니다. 이건 연습 삼아 직접 해보시기 바랍니다.</p>
<p style="line-height:130%;">3. 조합의 수</p>
<p style="line-height:130%;">n명의 사람들 중에 r명의 사람을 뽑는 방법의 수는? 
단 (0 &lt;= r &lt;= n)</p>
<p style="line-height:130%;">ex) 4명의 사람들 중에서 2명을 뽑는 방법의 수는?</p>
<p style="line-height:130%;">sol) 4명의 사람들을 각각 a, b, c, d라고 하면 뽑는 
방법의 수는<br>
{a, b} {a, c} {a, d} {b, c} {b, d} {c, d} 이렇게 총 6가지 이다. 결국 답은 6이다.</p>
<p style="line-height:130%;">이 문제는 별다른 힌트가 주어져 있지 않은 문제입니다. 
따라서 직접 문제를 분석해서 문제를 풀어나가는 방법 밖에 없습니다.</p>
<p style="line-height:130%;">1. 문제가 최적화의 원리가 성립하는지 검사(즉 동적 
계획법으로 해결할 수 있는지)</p>
<ul>
    <p style="line-height:130%;">이것 역시 또 생략...</p>
</ul>
<p style="line-height:130%;">2. 부분문제를 정의한다.</p>
<ul>
    <p style="line-height:130%;">그냥 간단하게 'C(i, j) = i명의 사람들 중에 
    j명의 사람을 뽑는 방법의 수'라고 정의하도록 하죠. </p>
    <p style="line-height:130%;">앞의 두개의 문제와는 달리 이번에는 테이블이 
    2차원으로 정의가 되면 &quot;2차원 동적계획법&quot;이라고 합니다. 마찬가지로 
    3차원으로 정의 되면 &quot;3차원 동적계획법&quot;이라고 하구요. 일반적으로 
    차원이 높아질 수록 메모리 사용량이 크고 더 복잡해 집니다.</p>
</ul>
<p style="line-height:130%;">3. 우리가 구해야 하는 큰 문제는 어떻게 정의되는지 
알아본다.</p>
<ul>
    <p style="line-height:130%;">부분문제의 정의해 따라 C(n, r)을 구하면 됩니다.</p>
</ul>
<p style="line-height:130%;">4. 큰 문제와 작은 문제간의 관계를 찾는다. 즉, 점화식을 
구한다.</p>
<p style="line-height:130%;">이 부분이 어렵습니다. 과연 C(i, j)를 구하기 위해서는 
어떻게 해야 할까요?</p>
<ul>
    <p style="line-height:130%;">일단 간단한 경우, C(i, 0)의 경우엔 무조건 값은 
    1이 됩니다. 하나도 뽑으면 안되니까 결국 공집합의 한가지 경우만 있습니다. 
    C(i, i)의 경우 (즉, i와 j가 같을 때)도 무조건 값은 1입니다. 모든 사람을 
    전부 다 뽑아야 하니까 경우의 수는 전체집합 한가지 경우만 있으므로 1이 됩니다.</p>
    <p style="line-height:130%;">i명의 사람들이 있다고 할 때, 각각의 사람들에 
    1, 2, ..., i 이렇게 번호를 붙여 봅시다. 그럼 i번째 사람의 입장에서 볼 때, 
    두가지의 경우를 정의해 볼 수 있습니다.
    <table border cellspacing="0" bordercolordark="white" bordercolorlight="black">
            <tr>
                <td width="367"><p align="center"><img src="dynamic2.bmp" width="291"
                 height="171" border="0"></p>
                <p align="center">1) i번째 사람이 뽑힌다.</p>
                <p align="center" style="line-height:130%;"><font size="2">i번째 
                사람이 뽑히면 나머지 i - 1명의 사람들 중에서 <br>
                j - 1명을 더 뽑아야 합니다.</font></td>
            <td width="367"><p align="center"><img src="dynamic3.bmp" width="302"
                 height="163" border="0"></p>
                <p align="center">2) i번째 사람이 뽑히지 않는다.</p>
                <p align="center" style="line-height:130%;"><font size="2">i번째 
                사람이 뽑히지 않으면 나머지 i - 1명의 사람들 중에서 j명을 뽑아햐 
                한다.</font></td>
        </tr>
    </table>
    <p style="line-height:130%;">1)과 2)는 서로 배반사건입니다.(이건 고등학교 
    가면 배워요..) 이것은 덧셈정리에 의하여,</p>
    <p style="line-height:130%;">'i명의 사람중에 j명의 사람을 경우의 수 = i 
    - 1명의 사람중에 j - 1명을 뽑는 경우의 수 + i - 1명의 사람중에 j명을 뽑는 
    경우의 수' 가 됩니다.</p>
    <p style="line-height:130%;">지금까지의 내용을 정리해 보면 다음과 같은 점화식이 
    나옵니다.</p>
    <p style="line-height:130%;"><font face="굴림체" color="red">C(i, j) : j 
    = 0일 경우 1<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j = i일 경우 
    1<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;그 외의 경우 
    C(i - 1, j - 1) + C(i - 1, j)</font></p>
    <p style="line-height:130%;">이 내용은 반드시 이해를 하시고 넘어가셔야 합니다.</p>
</ul>
<p style="line-height:130%;">5. 점화식을 통해 작은 문제들을 어떤 순서로 구해 
나갈 것인지를 결정한다.</p>
<ul>
    <p style="line-height:130%;">C(i, j)를 구하기 위해서는 C(i - 1, ...)가 미리 
    구해져 있어야 합니다. 이 말은 C(1, ...)부터 C(n, ...)까지 차례로 구해 나가면 
    된다는 뜻이죠.</p>
</ul>
<p style="line-height:130%;">6. 답을 얻는 과정을 추적하는 방법을 세워야 한다.</p>
<ul>
    <p style="line-height:130%;">이 문제에서는 역시 필요 없죠?</p>
</ul>
<p style="line-height:130%;">이제 소스를 보도록 하겠습니다. 역시 방금 한 정의의 
내용을 잘 따르고 있으므로 해석하는 데에는 별 어려움이 없으리라 생각됩니다.</p>
<p style="line-height:130%;"><font face="굴림체">program Combination_Dynamic;</font></p>
<p style="line-height:130%;"><font face="굴림체">var<br>
&nbsp;&nbsp;Table : array[0..100, 0..100] of integer;<br>
&nbsp;&nbsp;n, r &nbsp;: integer;<br>
&nbsp;&nbsp;i, j &nbsp;: integer;<br>
begin<br>
&nbsp;&nbsp;readln (n, r);</font></p>
<p style="line-height:130%;"><font face="굴림체">&nbsp;&nbsp;for i := 0 to n 
do<br>
&nbsp;&nbsp;&nbsp;&nbsp;for j := 0 to i do<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (j = 0) or (j = i) then<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Table[i, j] := 1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Table[i, j] := Table[i - 1, 
j] + Table[i - 1, j - 1];</font></p>
<p style="line-height:130%;"><font face="굴림체">&nbsp;&nbsp;writeln (Table[n, 
r]);<br>
end.</font></p>
<p style="line-height:130%;">4 2를 넣으면 6이 나오는 것을 확인할 수 있습니다. 
위 프로그램이 실행되고 나서 테이블 배열을 나열해 보면 다음과 같이 됩니다.</p>
<p style="line-height:130%;"><font face="굴림체">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 1<br>
&nbsp;&nbsp;&nbsp;&nbsp;1 2 1<br>
&nbsp;&nbsp;&nbsp;1 3 3 1<br>
&nbsp;&nbsp;1 4 6 4 1<br>
&nbsp;&nbsp;...</font></p>
<p style="line-height:130%;">왠지 낯이 익지 않나요? 바로 이것이 파스칼의 삼각형입니다. 
윗 줄의 인접한 두개의 수를 더한 것이 파스칼의 삼각형인데, 우리가 세운 점화식과 
똑같죠? 파스칼의 삼각형은 조합의 수를 나타냅니다.</p>
<p style="line-height:130%;">이번 내용은 좀 길어 졌군요. 예로 든 문제가 쉬었으므로, 
이해하는 데에는 별 문제가 없으셨으리라 생각합니다. 다음에는 좀 더 어렵고 많은 
생각이 필요한 문제들과 함께 더 깊이 배워보도록 하겠습니다.</p>
<p style="line-height:130%;">&nbsp;</p>
</body>

</html></html>