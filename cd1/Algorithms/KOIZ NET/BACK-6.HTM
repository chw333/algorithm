<html>

<head>
<meta http-equiv="content-type" content="text/html; charset=ks_c_5601-1987">
<title>0/1 배낭 문제</title>
</head>

<body bgcolor="white" text="black" link="blue" vlink="purple" alink="red">
<p align="center"><font size="5" color="#0066CC"><b>0/1 배낭 문제</b></font></p>
<p><font size="2">&nbsp;</font></p>
<p><font size="2">문제 설명</font></p>
<p><font size="2">용량이 W인 배낭에 물건들을 담으려고 한다. 물건은 모두 n개가 
있는데, 각 물건 i의 무게는 wi이고 이것을 배낭에 넣을 경우 pi만큼 이득을 얻는다. 
배낭에 넣은 물건의 무게의 총합이 W를 초과하지 않도록 하면서 최대 이득을 얻을 
수 있도록 배낭에 넣을 물건들의 양 xi를 결정하라. (0&lt;=xi&lt;=1)</font></p>
<p><font size="2">예를 들어, 배낭의 용량이 16이고 물건이 모두 4개 있다고 하자. 
그리고 각 물건의 가치 p[1..4] = { 40, 30, 50, 10 } 이고 무게 w[1..4]= (2,5,10,5) 
라고 하자. 각 물건에 대해 배낭에 넣을 양 x[1..4]=(1,0,1/2,1) 이면, 물건 1은 
전체를 담고, 물건2은 전혀 담지 않고 물건 3은 절반만 담고, 물건 4는 전체를 담는 
것을 의미한다. 따라서 총 무게는 2+0+10/2+5=12이고, 총이득은 40+0+25+10=75 가 
된다. x[1..4]=(1,0,1,0)이면 총 무게는 2+0+10+0=12이고, 총 이득은 40+0+50+0=90이 
된다.</font></p>
<p><font size="2">&nbsp;</font></p>
<p><font size="2">xi의 값에 0과 1사이의 소수를 허용하면 분할가능 배낭 문제(fractional 
knapsack problem)이라고 부르고, 0과 1만 허용하면 0/1 배낭 문제 (0/1 knapsack 
problem)이라고 부른다. 분할 가능 배낭 문제에서는 물건들을 쪼개서 배낭에 넣을 
수 있으나, 0/1배낭 문제에서는 물건을 통채로 배낭 넣든지 아니면 버리든지 결정해야한다. 
분할가능 배낭 문제는 욕심쟁이법으로 해결할 수 있는 쉬운 문제이고, 0/1 배낭 문제는 
NP-hard에 속하는 문제로서 욕심쟁이법과 동저계획법으로 다항 시간(polynomial time)에 
풀리지 않는 어려운 문제이다.</font></p>
<p><font size="2">&nbsp;</font></p>
<p><font size="2">이 문제에 대한 간단한 방법을 생각해보자. 0/1 배낭 문제의 해는 
배낭에 담을 물건들의 부분집합을 결정하는 문제이므로 부분집합의 합문제와 마찬가지로 
모든 부분집합들을 하나 하나 조사한다면 해를 찾을 수 있다. n개의 원소의 집합에 
대한 부분집합의 수는 모두 2^n개가 있으므로 이 방법으로 문제를 풀기 위해서는 
Ω(2^n)시간이 필요하다.</font></p>
<p><font size="2">&nbsp;</font></p>
<p><font size="2">한계 함수</font></p>
<p><font size="2">0/1 배낭 문제의 해의 표현으로 고정 코기 순서리스트 (x1,x2,...,xn)를 
사용한다고 하자. 여기서 xi는 물건 i를 배낭에 넣으면 1, 아니면 0 값을 가지게 
된다. 이에 따른 상태공간트리는 부분집합의 합문제에서 고정크기 순서리스트 방식의 
상태공간트리와 동일하게 구성된다.</font></p>
<p><font size="2">&nbsp;</font></p>
<p><font size="2">이제, 0/1 배낭 문제의 한계 함수에 대해 살펴보자. 최적화 문제의 
경우 퇴각검색법의 한계 함수는 주로 다음과 같이 설정하게 된다.</font></p>
<p><font size="2">&nbsp;</font></p>
<p><font size="2">상태공간트리의 각노드에서 추정할수 있는 이득의 상한이 지금까지 
조사된 해들중에서 가장 좋은 해의 값(이득의 하한)보다 같거나 작은면 퇴각한다.</font></p>
<p><font size="2">&nbsp;</font></p>
<p><font size="2">위의 방식에 따라 0/1 배낭 문제의 한계함수를 설계해보자. 상태공간트리의 
각노드에서 이득의 상한을 어떻게 추정할 것인가? 같은 입력에 대해 0/1배낭 문제와 
분할 가능 배낭 문제의 해를 비교해볼 때, 분할 가능 문제의 해는 0/1배낭문제의 
해를 비해 항상 총 이득이 같거나 크는 것을 알 수 있다. 그래서, 분할가능 문제의 
해는 0/1 배낭 문제의 해에 대한 상한으로 설정할 수 있다. 결과적으로 상태공간트리의 
각 노드 x에서 이득의 상한 값은 bound를 다음과 같이 설정할 수 있다.</font></p>
<p><font size="2">&nbsp;</font></p>
<p><font size="2">bound(x) = 현재까지 선택된 물건들의 이득의 합 + 남은 물건들과 
남은 용량에 대한 분할 가능 배낭 문제의 해의 이득</font></p>
<p><font size="2">상태공간트리의 각 노드 x를 방문할 시점 까지 조사된 최고 이득을 
maxprofit이라고 설정하면, &nbsp;x에 대한 한계 함수는 다음과 같이 설정할 수 있다.</font></p>
<p><font size="2">&nbsp;</font></p>
<p><font size="2">1. 노드 x에서 선택된 물건들의 무게의 합이 W를 초과하면 퇴각한다.</font></p>
<p><font size="2">2. 노드 x에서의 상한 bound가 maxprofit보다 같거나 작으면 퇴각한다.</font></p>
<p><font size="2">&nbsp;</font></p>
<p><font size="2">알고리즘</font></p>
<p><font size="2">알고리즘의 입력인 배낭의 용량 W와 물건들의 무게에 대한 배열 
w[1..n]과 이득에 대한 배열 p[1..n]는 모두 전역 변수로 설정되어 있다. 알고리즘의 
출력은 최대 이득(알고리즘에서의 maxprofit)과 최대이득을 주는 최척해의 표현인 
x[1..n](알고리즘에서의 bestset[1..n])이다.</font></p>
<p><font size="2">&nbsp;</font></p>
<p><font size="2">알고리즘은 knapsack()와 promising()으로 구성되어 있다. knapsack(i,profit,weight)의 
매개 변수에서 i는 현재 고려하지 않은 물건의 id(or index)를 의미하고, profit는 
현재까지 선택된 물건들의 이득의 합, weight는 현재까지 선택된 물건들의 무게의 
합을 의미합니다. knapsack()의 초기 호출에서 i=0,profit=0,weight =0가 됩니다.</font></p>
</body>

</html>
