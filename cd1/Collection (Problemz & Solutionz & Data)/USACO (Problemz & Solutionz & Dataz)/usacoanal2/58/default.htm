<html>
<head> <title>Analysis 58: The Clocks</title> </head>
<body background="../../usaco/bg3.jpg">
<img src="../../usaco/cow1.jpg" width="742" height="118">
<center>
<b><font size="7">The Clocks</font></b><br>
Russ Cox
</center>
<html>
<p>Notice that the order in which we apply moves is irrelevant,
and that applying a move four times is the same as applying it not at all.

<p>Thus there are only 4<sup>9</sup> = 262144 move sequences that need
to be tried, so we might as well just try them all.

<p>We don't generate them shortest first, but looking at sequences of
the same length, we generate the lesser ones before the greater ones,
so we only need to keep track of the shortest working sequence we've
found.

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;ctype.h&gt;

#define INF 60000	/* bigger than longest possible path */

char *movestr[] = { "abde", "abc", "bcef", "adg", "bdefh", "cfi", "degh",
                    "ghi", "efhi" };

int movedist[9][9];
int clock[9];

int bestmove[9];
int nbestmove;

/* translate move strings into array "movedist" of which clocks change on each move */
void
mkmove(void)
{
    int i;
    char *p;

    for(i=0; i&lt;9; i++)
	for(p=movestr[i]; *p; p++)
	    movedist[i][*p-'a'] = 3;
}

/* apply some number of each move from k to 9 */
/* move contains the number of times each move is applied */
void
solve(int *move, int k)
{
    int i, j, n, rep;

    if(k == 9) {
	for(j=0; j&lt;9; j++)
	    if(clock[j]%12 != 0)
		return;

	/* we have a successful sequence of moves */
	n = 0;
	for(j=0; j&lt;9; j++)
	    n += move[j];

	if(nbestmove == 0 || n &lt; nbestmove) {
	    nbestmove = n;
	    for(j=0; j&lt;9; j++)
		bestmove[j] = move[j];
	}
	return;
    }

    /*
     * the for loop counts down so we
     * generate smaller numbers first by
     * trying more of small numbered
     * moves before we try less of them.
     */
    for(rep=3; rep&gt;=0; rep--) {
	/* apply move k rep times */
	for(i=0; i&lt;rep; i++)
	    for(j=0; j&lt;9; j++)
		clock[j] += movedist[k][j];
	move[k] = rep;

	solve(move, k+1);

	/* undo move */
	for(i=0; i&lt;rep; i++)
	    for(j=0; j&lt;9; j++)
		clock[j] -= movedist[k][j];
    }
}

void
main(void)
{
    FILE *fin, *fout;
    int i, j, move[9];
    char *sep;

    fin = fopen("clocks.in", "r");
    fout = fopen("clocks.out", "w");
    assert(fin != NULL &amp;&amp; fout != NULL);

    mkmove();

    for(i=0; i&lt;9; i++)
	fscanf(fin, "%d", &amp;clock[i]);

    solve(move, 0);

    sep = "";
    for(i=0; i&lt;9; i++) {
	for(j=0; j&lt;bestmove[i]; j++) {
	    fprintf(fout, "%s%d", sep, i+1);
	    sep = " ";
	}
    }
    fprintf(fout, "\n");

    exit(0);
}
</pre>
<center>
<a href="../BACK/default.htm">USACO Gateway</a> | <a href="mailto:kolstad@ace.delos.com">Comment or Question</a>
</center>
</body>
