<html>
<head> <title>Analysis #99: Broken Necklace</title> </head>
<body background="../../usaco/bg3.jpg">
<img src="../../usaco/cow1.jpg" width="742" height="118">
<center>
<b><font size="7">Analysis: Broken Necklace</font></b><br>
Russ Cox
</center>

<p>In this problem, the necklace size is small enough (350) that we
might as well just try breaking the necklace at each point and see how
many beads can be collected.  This will take approximately O(n^2) time,
but n is small enough that it won't matter.

<p>The code is slightly simple-minded in that we might count the same beads
twice if they can be taken off either side of the break.  This can only
happen if all beads can be taken off the necklace, so we just check for
that at the end.

<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;

#define MAXN 400

char necklace[MAXN];
int len;

/* 
 * Return n mod m.  The C % operator is not enough because
 * its behavior is undefined on negative numbers.
 */
int 
mod(int n, int m)
{
    while(n &lt; 0)
	n += m;
    return n%m;
}

/*
 * Calculate number of beads gotten by breaking
 * before character p and going in direction dir,
 * which is 1 for forward and -1 for backward.
 */
int
nbreak(int p, int dir)
{
    char color;
    int i, n;

    color = 'w';

    /* Start at p if going forward, bead before if going backward */
    if(dir &gt; 0)
	i = p;
    else
	i = mod(p-1, len);

    /* We use "n&lt;len" to cut off loops that go around the whole necklace */
    for(n=0; n&lt;len; n++, i=mod(i+dir, len)) {
	/* record which color we're going to collect */
	if(color == 'w' &amp;&amp; necklace[i] != 'w')
	    color = necklace[i];

	/* 
	 * If we've chosen a color and see a bead
	 * not white and not that color, stop 
	 */
	if(color != 'w' &amp;&amp; necklace[i] != 'w' &amp;&amp; necklace[i] != color)
	    break;
    }
    return n;
}

void
main(void)
{
    FILE *fin, *fout;
    int i, n, m;

    fin = fopen("beads.in", "r");
    fout = fopen("beads.out", "w");
    assert(fin != NULL &amp;&amp; fout != NULL);

    fscanf(fin, "%d %s", &amp;len, necklace);
    assert(strlen(necklace) == len);

    m = 0;
    for(i=0; i&lt;len; i++) {
	n = nbreak(i, 1) + nbreak(i, -1);
	if(n &gt; m)
	    m = n;
    }

    /*
     * If the whole necklace can be gotten with a good
     * break, we'll sometimes count beads more than 
     * once.  this can only happen when the whole necklace
     * can be taken, when beads that can be grabbed from
     * the right of the break can also be grabbed from the left.
     */
    if(m &gt; len)
	m = len;

    fprintf(fout, "%d\n", m);
    exit (0);
}
</pre>
<br><br>
<center>
<a href="../BACK/default.htm"> USACO Gateway </a>  &nbsp;| &nbsp;
<a href="mailto:kolstad@ace.delos.com">Comment or Question </a>
</center>
</body>
</html>
