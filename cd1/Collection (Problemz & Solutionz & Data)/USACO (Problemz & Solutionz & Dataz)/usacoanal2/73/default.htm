<html>
<head> <title>Analysis 73: Shaping Regions</title> </head>
<body background="../../usaco/bg3.jpg">
<img src="../../usaco/cow1.jpg" width="742" height="118">
<center>
<b><font size="7">Shaping Regions</font></b><br>
Russ Cox
</center>
<html>

<p> <i>Russ's solution is written for a smaller version of the problem.</i>

<p>Since the grid is small enough (only 640,000 squares at most), we
can just use an array of characters, plot everything, and then count
colors.

<p>We use color numbers 0..99 rather than 1..100, making
white be 0 rather than 1.  Since the "paper" array starts out
all zeros, it starts out all white.

<p> [more comments below after the program]

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;

#define MAXDIM 800
#define MAXN 100
#define MAXCOLOR 100

char paper[MAXDIM][MAXDIM];

void
main(void)
{
	FILE *fin, *fout;
	int i, n, minx, miny, maxx, maxy, c, x, y;
	int wid, ht;
	int count[MAXCOLOR];

	fin = fopen("rect1.in", "r");
	fout = fopen("rect1.out", "w");
	assert(fin != NULL &amp;&amp; fout != NULL);

	fscanf(fin, "%d %d %d", &amp;wid, &amp;ht, &amp;n);
	for(i=0; i&lt;n; i++) {
		/* read, fill rectangle */
		fscanf(fin, "%d %d %d %d %d", &amp;minx, &amp;miny, &amp;maxx, &amp;maxy, &amp;c);
	
		for(x=minx; x&lt;maxx; x++)
		for(y=miny; y&lt;maxy; y++)
			paper[x][y] = c-1;
	}

	/* count rectangle colors */
	for(i=0; i&lt;MAXCOLOR; i++)
		count[i] = 0;

	for(x=0; x&lt;wid; x++)
	for(y=0; y&lt;ht; y++)
		count[paper[x][y]]++;

	/* print counts */
	for(i=0; i&lt;MAXCOLOR; i++)
		if(count[i])
			fprintf(fout, "%d %d\n", i+1, count[i]);

	exit(0);
}
</pre>


<h3>Further Analysis by Mathijs Vogelzang</h3>

<p>A straightforward approach to this problem would be to make an array
which represents the table, and then draw all the rectangles on it. In
the end, the program can just count the colors from the array and output
them.  Unfortunately, the maximum dimensions of this problem are 10,000
x 10,000, which means the program uses 100 million integers. That's too
much, so we need another approach.

<p>An approach that does work for such large cases (and it actually is
a lot faster too) is to keep track of the rectangles, and delete portions
of them when they are covered by other rectangles.

<p>Consider this input set:
<pre>
0 0 10 10 5
5 0 15 10 10
</pre>
<p>The program first reads in the first rectangle and puts it in a list.
When it reads a new rectangle it checks all items in the list if they
overlap with the new rectangle. This is the case, and then it deletes
the old rectangle from the list and adds all parts which aren't covered
to the list.  (So in this case, the program would delete the first
rectangle, add <tt>0 0 5 10 5</tt> to the list and then add the second rectangle
to the list).
``
<p>If you're unlucky, a new rectangle can create lots of new rectangles
(when the new rectangle entirely fits into another one, the program
creates four new rectangles which represent the leftover border:
<pre>
+--------+      +-+--+--+
|        |      | |2 |  |
|        |      + +--+  |
|  +-+   |  --> | |  |  |
|  +-+   |      |1|  |3 |
|        |      | +--+  |
|        |      | | 4|  |
+--------+      +-+--+--+
</pre>
This is not a problem however, because there can be only 2500 rectangles
and there is plenty of memory, so rectangles have to be cut very much
run out of memory.

<p>Note that with this approach, the only thing that matters is how many
rectangles there are and how often they overlap. The maximum dimensions
can be as large as you want, it doesn't matter for the running time.

<h3>Further Analysis by Tomek Czajka</h3>

<p>There is another solution to this problem, which runs in O(n*n*log
n) time, but is quite tricky.  First, we add one big white rectangle at
the bottom - the paper.  Then we make two arrays: one containing all
vertical edges of the rectangles, and the other the horizontal ones.
For each edge we have its coordinates and remember, whether it's the
left or right edge (top or bottom). We sort these edges from left to
right and from top to bottom.  Then we go from left to right (sweep),
jumping to every x-coordinate of vertical edges. At each step we update
the set of rectangles seen. We also want to update the amount of each
color seen so far. So for each x we go from top to bottom, for each y
updating the set of rectagles at a point (in the structure described
below) and choosing the top one, so that we can update the amounts of
colors seen.

<p>The structure to hold the set of rectangles at a point should allow
adding a rectangle (number from 1..1000), deleting a rectangle, and
finding the top one.  We can implement these operations in O(log n) time
if we use a heap. To make adding and deleting run in O(log n) we must
also have for each rectangle its position in the heap.

<p>So the total time spent at each point is O(log n). Thus the algorithm
works in O(n*n*log n) time.

<h3> And a solution from mrsigma:
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

FILE *fp,*fo;

struct rect
{
    int c;
    int x1,y1,x2,y2;
};

int c[2501];
rect r[10001];

int intersect(rect a,const rect &amp;b,rect out[4])
{
    /* do they at all intersect? */
    if(b.x2&lt;a.x1||b.x1&gt;=a.x2)
        return 0;
    if(b.y2&lt;a.y1||b.y1&gt;=a.y2)
            return 0;
    /* they do */

    rect t;

    if(b.x1&lt;=a.x1&amp;&amp;b.x2&gt;=a.x2&amp;&amp;b.y1&lt;=a.y1&amp;&amp;b.y2&gt;=a.y2)
            return -1;

    /* cutting `a' down to match b */
    int nout=0;
    if(b.x1&gt;=a.x1) {
        t=a,t.x2=b.x1;
        if(t.x1!=t.x2)
            out[nout++]=t;
        a.x1=b.x1;
    }
    if(b.x2&lt;a.x2) {
        t=a,t.x1=b.x2;
        if(t.x1!=t.x2)
            out[nout++]=t;
        a.x2=b.x2;
    }
    if(b.y1&gt;=a.y1) {
        t=a,t.y2=b.y1;
        if(t.y1!=t.y2)
            out[nout++]=t;
        a.y1=b.y1;
    }
    if(b.y2&lt;a.y2) {
        t=a,t.y1=b.y2;
        if(t.y1!=t.y2)
            out[nout++]=t;
        a.y2=b.y2;
    }
    return nout;
}

int main(void) {
    fp=fopen("rect1.in","rt");
    fo=fopen("rect1.out","wt");

    int a,b,n;
    fscanf(fp,"%d %d %d",&amp;a,&amp;b,&amp;n);

    r[0].c=1;
    r[0].x1=r[0].y1=0;
    r[0].x2=a;
    r[0].y2=b;

    rect t[4];

    int i,j,rr=1;
    for(i=0;i&lt;n;i++) {
        int tmp;
        fscanf(fp,"%d %d %d %d %d",&amp;r[rr].x1,&amp;r[rr].y1,&amp;r[rr].x2,&amp;r[rr].y2,&amp;r[rr].c);

        if(r[rr].x1&gt;r[rr].x2) {
            tmp=r[rr].x1;
            r[rr].x1=r[rr].x2;
            r[rr].x2=tmp;
        }
        if(r[rr].y1&gt;r[rr].y2) {
            tmp=r[rr].y1;
            r[rr].y1=r[rr].y2;
            r[rr].y2=tmp;
        }

        int nr=rr;
        rect curr=r[rr++];
        for(j=0;j&lt;nr;j++) {
            int n=intersect(r[j],curr,t);
            if(!n)
                continue;
            if(n==-1) {
                memmove(r+j,r+j+1,sizeof(rect)*(rr-j-1));
                j--;
                rr--;
                nr--;
                continue;
            }
            r[j]=t[--n];
            for(;n--&gt;0;)
                r[rr++]=t[n];
        }
    }

    for(i=0;i&lt;rr;i++)
        c[r[i].c]+=(r[i].x2-r[i].x1)*(r[i].y2-r[i].y1);

    for(i=1;i&lt;=2500;i++)
        if(c[i])
            fprintf(fo,"%d %d\n",i,c[i]);

    return 0;
}
</pre>

<center>
<a href="../BACK/default.htm">USACO Gateway</a> | <a href="mailto:kolstad@ace.delos.com">Comment or Question</a>
</center>
</body>
