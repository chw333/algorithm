<html>
<head> <title>Analysis 46: American Heritage</title> </head>
<body background="../../usaco/bg3.jpg">
<img src="../../usaco/cow1.jpg" width="742" height="118">
<center>
<b><font size="7">American Heritage</font></b><br>
Russ Cox
</center>
<html>
<p>We use a recursive procedure to generate the actual binary tree.
Once we have the tree, we execute a postorder traversal to
print the node values.

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;

FILE *fout;

typedef struct Tree Tree;
struct Tree {
    int c;
    Tree *left;
    Tree *right;
};

Tree*
mktree(int c, Tree *left, Tree *right)
{
    Tree *t;
    t = (Tree*)malloc(sizeof *t);
    assert(t);
    t-&gt;c = c;
    t-&gt;left = left;
    t-&gt;right = right;
    return t;
}

/*
 * Pre and in point at strings of length len
 * that describe the same tree, in pre-order
 * and in-order traversals.  Return a
 * corresponding binary tree.
 */
Tree*
prein2tree(char *pre, char *in, int len)
{
    char *p;
    int llen, rlen;

    assert(strlen(pre)&gt;=len &amp;&amp; strlen(in)&gt;=len);

    if(len == 0)
        return NULL;

    /*
     * The first character of the preorder traversal is the root.
     * If we find the root in the inorder traversal, then everything
     * to its left is on the left side, and everything to its right on the
     * right side.  Recur on both sides.
     */
    p = strchr(in, pre[0]);
    assert(p != NULL);
    assert(p-in &lt; len);

    llen = p-in;
    rlen = len-llen-1;
    return mktree(pre[0], prein2tree(pre+1, in, llen), prein2tree(pre+1+llen, p+1, rlen));
}

void
postorder(Tree *t)
{
    if(t == NULL)
        return;
    postorder(t-&gt;left);
    postorder(t-&gt;right);
    fprintf(fout, "%c", t-&gt;c);
}

void
main(void)
{
    FILE *fin;
    char pre[50], in[50];

    fin = fopen("heritage.in", "r");
    fout = fopen("heritage.out", "w");
    assert(fin != NULL &amp;&amp; fout != NULL);

    fscanf(fin, "%s %s", in, pre);
    postorder(prein2tree(pre, in, strlen(pre)));
    fprintf(fout, "\n");
    exit(0);
}
<pre>

<p> From Greg Price:

<p>We don't need to reconstruct the original tree explicitly for this
problem.  Instead, we use a recursive function that plucks the root from
the start of the preorder traversal, uses it to divide the inorder
traversal, calls itself recursively on the left and right subtrees, and
outputs the root.

<pre>
#include &lt;fstream.h&gt;
#include &lt;string.h&gt;

ifstream fin("heritage.in");
ofstream fout("heritage.out");

const short maxn = 26 + 2;

short len;
char in[maxn], pre[maxn];

void
makepost(short ina, short inb, short prea, short preb)
{
	char root;
	short rt_in;
	short lsize, rsize;

	if (ina == inb) // Null tree
		return;

	root = pre[prea];

	// Find root in inorder
	for (rt_in = ina; rt_in &lt; inb; rt_in++)
		if (in[rt_in] == root)
			break;

	// Size of left-hand subtree
	lsize = rt_in -  ina;

	makepost(ina,     rt_in, prea+1,         prea+1 + lsize); // Left
subtree
	makepost(rt_in+1, inb,   prea+1 + lsize, preb); // Right subtree
	fout &lt;&lt; root;
}

void
main()
{
	fin.getline(in , maxn);
	fin.getline(pre, maxn);

	len = strlen(in);

	makepost(0, len, 0, len);
	fout &lt;&lt; endl;
}
</pre>


<center>
<a href="../BACK/default.htm">USACO Gateway</a> | <a href="mailto:kolstad@ace.delos.com">Comment or Question</a>
</center>
</body>
