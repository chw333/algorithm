<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0060)http://ace.delos.com/usacotext/s=1.2.1.0/a=bbaPk9uaqQ3/flood -->
<HTML><HEAD><TITLE>Flood Fill</TITLE>
<META content="text/html; charset=ks_c_5601-1987" http-equiv=Content-Type>
<META content="MSHTML 5.00.2614.3500" name=GENERATOR></HEAD>
<BODY background="Flood Fill.files/bg3.jpeg"><IMG height=118 
src="Flood Fill.files/cow1.jpeg" width=742> 
<CENTER><B><FONT size=4>Flood Fill</FONT></B></CENTER>
<H4>Sample Problem: Connected Fields</H4>
<P>Farmer John's fields are broken into fields, with paths between some of them. 
Unfortunately, some fields are not reachable from other fields via the paths. 
<P>Define a <I>superfield</I> is a collection of fields that are all reachable 
from each other. Calculate the number of superfields. 
<H4>The Abstraction</H4>
<P>Given: a undirected graph 
<P>The <I>component</I> of a graph is a maximal-sized (though not necessarily 
maximum) subgraph which is connected. 
<P>Calculate the component of the graph. <BR><IMG 
src="Flood Fill.files/flood1.gif"><BR>This graph has three components: {1,4,8}, 
{2,5,6,7,9}, and {3}. 
<H4>The Algorithm: Flood Fill</H4>
<P>Flood fill can be performed three basic ways: depth-first, breadth-first, and 
breadth-first scanning. The basic idea is to find some node which has not been 
assigned to a component and to calculate the component which contains. The 
question is how to calculate the component. 
<P>In the depth-first formulation, the algorithm looks at each step through all 
of the neighbors of the current node, and, for those that have not been assigned 
to a component yet, assigns them to this component and recurses on them. 
<P>In the breadth-first formulation, instead of recursing on the newly assigned 
nodes, they are added to a queue. 
<P>In the breadth-first scanning formulation, every node has two values: 
component and visited. When calculating the component, the algorithm goes 
through all of the nodes that have been assigned to that component but not 
visited yet, and assigns their neighbors to the current component. 
<P>The depth-first formulation is the easiest to code and debug, but can require 
a stack as big as the original graph. For explicit graphs, this is not so bad, 
but for implicit graphs, such as the problem presented has, the numbers of nodes 
can be very large. 
<P>The breadth-formulation does a little better, as the queue is much more 
efficient than the run-time stack is, but can still run into the same problem. 
Both the depth-first and breadth-first formulations run in N + M time, where N 
is the number of vertices and M is the number of edges. 
<P>The breadth-first scanning formulation, however, requires very little extra 
space. In fact, being a little tricky, it requires no extra space. However, it 
is slower, requiring up to N*N + M time, where N is the number of vertices in 
the graph. 
<H4>Pseudocode for Breadth-First Scanning</H4>
<P>This code uses a trick to not use extra space, marking nodes to be visited as 
in component -2 and actually assigning them to the current component when they 
are actually visited. <BR><TT><FONT 
size=2><BR>#&nbsp;component(i)&nbsp;denotes&nbsp;the<BR>#&nbsp;component&nbsp;that&nbsp;node&nbsp;i&nbsp;is&nbsp;in<BR>&nbsp;1&nbsp;function&nbsp;flood_fill(new_component)&nbsp;<BR><BR>&nbsp;2&nbsp;do<BR>&nbsp;3&nbsp;&nbsp;&nbsp;num_visited&nbsp;=&nbsp;0<BR>&nbsp;4&nbsp;&nbsp;&nbsp;for&nbsp;all&nbsp;nodes&nbsp;i<BR>&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;component(i)&nbsp;=&nbsp;-2<BR>&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num_visited&nbsp;=&nbsp;num_visited&nbsp;+&nbsp;1<BR>&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;component(i)&nbsp;=&nbsp;new_component<BR>&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;all&nbsp;neighbors&nbsp;j&nbsp;of&nbsp;node&nbsp;i<BR>&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;component(i)&nbsp;=&nbsp;nil<BR>10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;component(i)&nbsp;=&nbsp;-2<BR>11&nbsp;until&nbsp;num_visited&nbsp;=&nbsp;0&nbsp;<BR><BR>12&nbsp;function&nbsp;find_components&nbsp;<BR><BR>13&nbsp;&nbsp;num_components&nbsp;=&nbsp;0<BR>14&nbsp;&nbsp;for&nbsp;all&nbsp;nodes&nbsp;i<BR>15&nbsp;&nbsp;&nbsp;&nbsp;component(node&nbsp;i)&nbsp;=&nbsp;nil<BR>16&nbsp;&nbsp;for&nbsp;all&nbsp;nodes&nbsp;i<BR>17&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;component(node&nbsp;i)&nbsp;is&nbsp;nil<BR>18&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num_components&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num_components&nbsp;+&nbsp;1<BR>19&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;component(i)&nbsp;=&nbsp;-2<BR>20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flood_fill(component<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num_components)<BR></FONT></TT>
<P>Running time of this algorithm is O(<I>N <SUP>2</SUP></I>), where <I>N</I> is 
the numbers of nodes. Every edge is traversed twice (once for each end-point), 
and each node is only marked once. 
<H4>Execution Example</H4>
<P>Consider the graph from above. <BR><IMG 
src="Flood Fill.files/flood1.gif"><BR>
<P>The algorithm starts with all nodes assigned to no component. 
<P>Going through the nodes in order first node not assigned to any component yet 
is vertex 1. Start a new component (component 1) for that node, and set the 
component of node 1 to -2 (any nodes not shown are unassigned). 
<CENTER>
<TABLE border=1>
  <TBODY>
  <TR>
    <TD align=middle>Node</TD>
    <TD align=middle>Component</TD></TR>
  <TR>
    <TD align=middle><B>1</B></TD>
    <TD align=middle><B>-2</B></TD></TR></TBODY></TABLE></CENTER>
<P>Now, in the <TT>flood_fill</TT> code, the first time through the <TT>do</TT> 
loop, it finds the node 1 is assigned to component -2. Thus, it reassigns it to 
component 1, signifying that it has been visited, and then assigns its neighbors 
(node 4) to component -2. 
<CENTER>
<TABLE border=1>
  <TBODY>
  <TR>
    <TD align=middle>Node</TD>
    <TD align=middle>Component</TD></TR>
  <TR>
    <TD align=middle><B>1</B></TD>
    <TD align=middle><B>1</B></TD></TR>
  <TR>
    <TD align=middle><B>4</B></TD>
    <TD align=middle><B>-2</B></TD></TR></TBODY></TABLE></CENTER>
<P>As the loop through all the nodes continues, it finds that node 4 is also 
assigned to component -2, and processes it appropriately as well. 
<CENTER>
<TABLE border=1>
  <TBODY>
  <TR>
    <TD align=middle>Node</TD>
    <TD align=middle>Component</TD></TR>
  <TR>
    <TD align=middle>1</TD>
    <TD align=middle>1</TD></TR>
  <TR>
    <TD align=middle><B>4</B></TD>
    <TD align=middle><B>1</B></TD></TR>
  <TR>
    <TD align=middle><B>8</B></TD>
    <TD align=middle><B>-2</B></TD></TR></TBODY></TABLE></CENTER>
<P>Node 8 is the next to be processed. 
<CENTER>
<TABLE border=1>
  <TBODY>
  <TR>
    <TD align=middle>Node</TD>
    <TD align=middle>Component</TD></TR>
  <TR>
    <TD align=middle>1</TD>
    <TD align=middle>1</TD></TR>
  <TR>
    <TD align=middle>4</TD>
    <TD align=middle>1</TD></TR>
  <TR>
    <TD align=middle><B>8</B></TD>
    <TD align=middle><B>1</B></TD></TR></TBODY></TABLE></CENTER>
<P>Now, the <TT>for</TT> loop continues, and finds no more nodes that have not 
been assigned yet. Since the <TT>until</TT> clause is not satisfied ( 
<TT>num_visited</TT> = 3), it tries again. This time, no nodes are found, so the 
function exits and component 1 is complete. 
<P>The search for unassigned nodes continues, finding node 2. A new component 
(component 2) is allocated, node 2 is marked as in component -2, and 
<TT>flood_fill</TT> is called. 
<CENTER>
<TABLE border=1>
  <TBODY>
  <TR>
    <TD align=middle>Node</TD>
    <TD align=middle>Component</TD></TR>
  <TR>
    <TD align=middle>1</TD>
    <TD align=middle>1</TD></TR>
  <TR>
    <TD align=middle><B>2</B></TD>
    <TD align=middle><B>-2</B></TD></TR>
  <TR>
    <TD align=middle>4</TD>
    <TD align=middle>1</TD></TR>
  <TR>
    <TD align=middle>8</TD>
    <TD align=middle>1</TD></TR></TBODY></TABLE></CENTER>
<P>Node 2 is found as marked in component -2, and is processed. 
<CENTER>
<TABLE border=1>
  <TBODY>
  <TR>
    <TD align=middle>Node</TD>
    <TD align=middle>Component</TD></TR>
  <TR>
    <TD align=middle>1</TD>
    <TD align=middle>1</TD></TR>
  <TR>
    <TD align=middle>2</TD>
    <TD align=middle>2</TD></TR>
  <TR>
    <TD align=middle>4</TD>
    <TD align=middle>1</TD></TR>
  <TR>
    <TD align=middle><B>7</B></TD>
    <TD align=middle><B>-2</B></TD></TR>
  <TR>
    <TD align=middle>8</TD>
    <TD align=middle>1</TD></TR>
  <TR>
    <TD align=middle><B>9</B></TD>
    <TD align=middle><B>-2</B></TD></TR></TBODY></TABLE></CENTER>
<P>Next, node 7 is processed. 
<CENTER>
<TABLE border=1>
  <TBODY>
  <TR>
    <TD align=middle>Node</TD>
    <TD align=middle>Component</TD></TR>
  <TR>
    <TD align=middle>1</TD>
    <TD align=middle>1</TD></TR>
  <TR>
    <TD align=middle>2</TD>
    <TD align=middle>2</TD></TR>
  <TR>
    <TD align=middle>4</TD>
    <TD align=middle>1</TD></TR>
  <TR>
    <TD align=middle><B>5</B></TD>
    <TD align=middle><B>-2</B></TD></TR>
  <TR>
    <TD align=middle><B>7</B></TD>
    <TD align=middle><B>2</B></TD></TR>
  <TR>
    <TD align=middle>8</TD>
    <TD align=middle>1</TD></TR>
  <TR>
    <TD align=middle>9</TD>
    <TD align=middle>-2</TD></TR></TBODY></TABLE></CENTER>
<P>Then node 9 is processed. 
<CENTER>
<TABLE border=1>
  <TBODY>
  <TR>
    <TD align=middle>Node</TD>
    <TD align=middle>Component</TD></TR>
  <TR>
    <TD align=middle>1</TD>
    <TD align=middle>1</TD></TR>
  <TR>
    <TD align=middle>2</TD>
    <TD align=middle>2</TD></TR>
  <TR>
    <TD align=middle>4</TD>
    <TD align=middle>1</TD></TR>
  <TR>
    <TD align=middle>5</TD>
    <TD align=middle>-2</TD></TR>
  <TR>
    <TD align=middle>7</TD>
    <TD align=middle>2</TD></TR>
  <TR>
    <TD align=middle>8</TD>
    <TD align=middle>1</TD></TR>
  <TR>
    <TD align=middle><B>9</B></TD>
    <TD align=middle><B>2</B></TD></TR></TBODY></TABLE></CENTER>
<P>The terminating condition does not hold ( <TT>num_visited</TT> = 3), so the 
the search through for nodes assigned to component -2 starts again. Node 5 is 
the first one found. 
<CENTER>
<TABLE border=1>
  <TBODY>
  <TR>
    <TD align=middle>Node</TD>
    <TD align=middle>Component</TD></TR>
  <TR>
    <TD align=middle>1</TD>
    <TD align=middle>1</TD></TR>
  <TR>
    <TD align=middle>2</TD>
    <TD align=middle>2</TD></TR>
  <TR>
    <TD align=middle>4</TD>
    <TD align=middle>1</TD></TR>
  <TR>
    <TD align=middle>5</TD>
    <TD align=middle>2</TD></TR>
  <TR>
    <TD align=middle><B>6</B></TD>
    <TD align=middle><B>-2</B></TD></TR>
  <TR>
    <TD align=middle>7</TD>
    <TD align=middle>2</TD></TR>
  <TR>
    <TD align=middle>8</TD>
    <TD align=middle>1</TD></TR>
  <TR>
    <TD align=middle>9</TD>
    <TD align=middle>2</TD></TR></TBODY></TABLE></CENTER>
<P>Node 6 is the next node found to be in component -2. 
<CENTER>
<TABLE border=1>
  <TBODY>
  <TR>
    <TD align=middle>Node</TD>
    <TD align=middle>Component</TD></TR>
  <TR>
    <TD align=middle>1</TD>
    <TD align=middle>1</TD></TR>
  <TR>
    <TD align=middle>2</TD>
    <TD align=middle>2</TD></TR>
  <TR>
    <TD align=middle>4</TD>
    <TD align=middle>1</TD></TR>
  <TR>
    <TD align=middle>5</TD>
    <TD align=middle>2</TD></TR>
  <TR>
    <TD align=middle><B>6</B></TD>
    <TD align=middle><B>2</B></TD></TR>
  <TR>
    <TD align=middle>7</TD>
    <TD align=middle>2</TD></TR>
  <TR>
    <TD align=middle>8</TD>
    <TD align=middle>1</TD></TR>
  <TR>
    <TD align=middle>9</TD>
    <TD align=middle>2</TD></TR></TBODY></TABLE></CENTER>
<P>No more nodes are found assigned to component -2, but the terminating 
condition does not hold, so one more pass through the nodes is performed, 
finding no nodes assigned to component -2. Thus, the search for unassigned nodes 
continue from node 2, finding node 3 unassigned. 
<CENTER>
<TABLE border=1>
  <TBODY>
  <TR>
    <TD align=middle>Node</TD>
    <TD align=middle>Component</TD></TR>
  <TR>
    <TD align=middle>1</TD>
    <TD align=middle>1</TD></TR>
  <TR>
    <TD align=middle>2</TD>
    <TD align=middle>2</TD></TR>
  <TR>
    <TD align=middle><B>3</B></TD>
    <TD align=middle><B>-2</B></TD></TR>
  <TR>
    <TD align=middle>4</TD>
    <TD align=middle>1</TD></TR>
  <TR>
    <TD align=middle>5</TD>
    <TD align=middle>2</TD></TR>
  <TR>
    <TD align=middle>6</TD>
    <TD align=middle>2</TD></TR>
  <TR>
    <TD align=middle>7</TD>
    <TD align=middle>2</TD></TR>
  <TR>
    <TD align=middle>8</TD>
    <TD align=middle>1</TD></TR>
  <TR>
    <TD align=middle>9</TD>
    <TD align=middle>2</TD></TR></TBODY></TABLE></CENTER>
<P>Node 3 is processed. 
<CENTER>
<TABLE border=1>
  <TBODY>
  <TR>
    <TD align=middle>Node</TD>
    <TD align=middle>Component</TD></TR>
  <TR>
    <TD align=middle>1</TD>
    <TD align=middle>1</TD></TR>
  <TR>
    <TD align=middle>2</TD>
    <TD align=middle>2</TD></TR>
  <TR>
    <TD align=middle>3</TD>
    <TD align=middle>3</TD></TR>
  <TR>
    <TD align=middle>4</TD>
    <TD align=middle>1</TD></TR>
  <TR>
    <TD align=middle>5</TD>
    <TD align=middle>2</TD></TR>
  <TR>
    <TD align=middle>6</TD>
    <TD align=middle>2</TD></TR>
  <TR>
    <TD align=middle>7</TD>
    <TD align=middle>2</TD></TR>
  <TR>
    <TD align=middle>8</TD>
    <TD align=middle>1</TD></TR>
  <TR>
    <TD align=middle>9</TD>
    <TD align=middle>2</TD></TR></TBODY></TABLE></CENTER>
<P>From here, the algorithm eventually terminates, as there are no more nodes 
assigned to component -2 and no unassigned nodes. The three components of the 
graph have been determined, along with the component to which each node belongs. 

<H4>Problem Cues</H4>
<P>Generally, these types of problem are fairly clear. If it asks for sets of 
"connected" things, it's probably asking for components, in which case flood 
fill works very well. Often, this is a step in solving the complete problem. 
<H4>Extensions</H4>
<P>The notion of ``components'' becomes muddied when you go to directed graphs. 
<P>However, the same flooding idea can be used to determine the points which are 
reachable from any given point even in a directed graph. At each recursive step, 
if the point isn't marked already, mark the point as reachable and recurse on 
all of its neighbors. 
<P>Note that to determine which points can reach a given point in a directed 
graph can be solved the same, by looking at every arc backwards. 
<H4>Sample Problems</H4>
<H5>Company Ownership [abridged, IOI 93]</H5>
<P>Given: A weighted directed graph, with weights between 0 and 100. 
<P>Some vertex A ``owns'' another vertex B if: 
<UL>
  <LI>A = B 
  <LI>There is an arc from A to B with weight more than 50. 
  <LI>There exists some set of vertices <I>C <SUB>1</SUB></I> through <I>C 
  <SUB>k</SUB></I> such that A owns <I>C <SUB>1</SUB></I> through <I>C 
  <SUB>k</SUB></I>, and each vertex has an arc of weight <I>x <SUB>1</SUB></I> 
  through <I>x <SUB>k</SUB></I> to vertex B, and <I>x <SUB>1</SUB></I> + <I>x 
  <SUB>2</SUB></I> + ... + <I>x <SUB>k</SUB></I> &gt; 50. </LI></UL>
<P>Find all (a,b) pairs such that a owns b. 
<P>Analysis: This can be solved via an adaptation of the calculating the 
vertices reachable from a vertex in a directed graph. To calculate which 
vertices vertex A owns, keep track of the ``ownership percentage'' for each 
node. Initialize them all to zero. Now, at each recursive step, mark the node as 
owned by vertex A and add the weight of all outgoing arcs to the ``ownership 
percentages.'' For all percentages that go above 50, recurse into those 
vertices. 
<H4>Street Race [IOI 95]</H4>
<P>Given: a directed graph, and a start point and an end point. 
<P>Find all points p that any path from the start point to the end must travel 
through p. 
<P>Analysis: The easiest algorithm is to remove each point in turn, and check to 
see if the end point is reachable from the start point. This runs in O(N (M + 
N)) time. Since the original problem stated that M &lt;= 100, and N &lt;= 50, 
this will run in time easily. 
<H4>Cow Tours [1999 USACO National Championship, abridged]</H4>
<P>The diameter of a connected graph is defined as the maximum distance between 
any two nodes of the graph, where the distance between two nodes is defined as 
the length of the shortest path. 
<P>Given a set of points in the plane, and the connections between those points, 
find the two points which are currently not in the same component, such that the 
diameter of the resulting component is minimized. 
<P>Analysis: Find the components of the original graph, using the method 
described above. Then, for each pair of points not in the same component, try 
placing a connection between them. Find the pair that minimizes the diameter. 
<H4>Connected Fields</H4>
<P>Farmer John contracted out the building of a new barn. Unfortunately, the 
builder mixed up the plans of Farmer John's barn with another set of plans. 
Farmer John's plans called for a barn that only had one room, but the building 
he got might have many rooms. Given a grid of the layout of the barn, tell 
Farmer John how many rooms it has. 
<P>Analysis: The graph here is on the non-wall grid locations, with edge between 
adjacent non-wall locations, although the graph should be stored as the grid, 
and not transformed into some other form, as the grid is so compact and easy to 
work with. <BR><BR>
<CENTER><A href="mailto:grader@ace.delos.com">Submit Solution via Email</A> 
&nbsp;|&nbsp; <A href="http://ace.delos.com/usacogate?a=bbaPk9uaqQ3">USACO 
Gateway </A>&nbsp;| &nbsp; <A href="mailto:kolstad@ace.delos.com">Comment or 
Question </A></CENTER></BODY></HTML>
