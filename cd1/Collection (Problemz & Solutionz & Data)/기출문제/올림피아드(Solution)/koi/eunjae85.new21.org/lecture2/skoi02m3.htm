<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
<head>
<title>KOI 19회 중등부 3. DNA</title>
<meta name="generator" content="Namo WebEditor v5.0">
</head>

<body bgcolor="white" text="black" link="blue" vlink="purple" alink="red">

<table border="0" width="595">
    <tr>
        <td width="383" height="27" bgcolor="#CFD3FF"><p><font size="4"><b>&nbsp;&nbsp;KOI 
            19회 중등부 3. DNA 유사도</b></font></td>
        <td width="100" height="27" bgcolor="#CFD3FF"><p align="center"><a href="pkoi02m3.htm"><img src="button1.gif"
             border="0"></a></td>
        <td width="100" height="27" bgcolor="#CFD3FF"><p align="center"><a href="ckoi02m3.htm"><img src="button3.gif"
             border="0"></a></td>
    </tr>
</table>
<ul>
    <p>&nbsp; 
    <table border="0" style='line-height:170%'>
            <tr>
                <td width="550" height="210">
                <p><font size="2">&nbsp;&nbsp;이 문제는 긴 시간을 두고 생각해 
                볼 만한 가치가 있는 문제입니다. 상당 시간 동안 고민을 해보시기 
                바라며, 충분히 고민을 했는데도 잘 모르겠을 때 보시기 바랍니다. 
                </font></p>
                <p><font size="2">&nbsp;&nbsp;상당히 흥미로운 문제입니다. 생각해 볼 게 많은 
                문제입니다. 일단 결론부터 말하자면, 동적 계획법을 이용해서 푸는 
                문제인데, 어찌 된게 점화식 세우는 것 보다 역추적하는 부분이 
                훨씬 어렵군요^^; </font></p>
                <p><font size="2">&nbsp;&nbsp;일단 입력 데이터는 거꾸로 받아들입니다. </font></p>
                <p><font size="2">1 <br>6 <br>AGTCAC <br>8 <br>GATGAGAC </font></p>
                <p><font size="2">&nbsp;&nbsp;이런 데이터가 있다면 Data1 = &quot;CACTGA&quot;, 
                Data2 = &quot;CAGAGTAG&quot; 이런식으로 입력을 받습니다. 왜 
                그런지는 좀 있다 알게 됩니다. </font></p>
                <p><font size="2">C[i, j] = Data1 에서의 1~i 부분과, Data2 에서의 
                1~j 부분의 최장 공통 K-부분 서열의 길이. </font></p>
                <p><font size="2">&nbsp;&nbsp;이렇게 부분문제를 정의하구요, </font></p>
                <p>&nbsp;</p>
                <p><font size="2" color="blue">i) Data1[i] &lt;&gt; Data2[j] 일 때, <br> 
                </font><font size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>C[i, j] = fmax{ C[i - 1, 
                j], C[i, j - 1] } </b></font></p>
                <p><font size="2" color="blue">ii) Data1[i] = Data2[j] 일 때, <br></font><font size="2"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>C[i, 
                j] = fmax{ C[l1, l2] + 1 } <br></b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font><font size="2" color="red">(단, i-k-1 &lt;= 
                l1 &lt;= i - 1, j-k-1 &lt;= l2 &lt;= j - 1, Data1[l1] = Data2[l2]) 
                </font></p>
                <p><font size="2">&nbsp;&nbsp;이렇게 점화식이 됩니다. 뭐 점화식 설명은 그리 
                중요하지 않은 듯 하니 넘어가겠습니다. 좀만 뜯어보시면 이해가 
                갈 겁니다. </font></p>
                <p><font size="2">&nbsp;&nbsp;그러면 이 문제의 가장 중요한 부분인 역추적 
                부분을 설명해드리겠습니다. </font></p>
                <p><font size="2">&nbsp;</font></p>
                <p><font size="2">&nbsp;&nbsp;구해질 수 있는 &quot;최장 공통 K-부분 서열&quot; 
                중 알파벳 순으로 가장 빠른 것을 출력해야 하기 때문에 어려운데요. 
                </font></p>
                <p><font size="2">&nbsp;&nbsp;&nbsp;핵심적인 것은 &quot;BFS&quot; 를 이용한다는 
                점입니다. &quot;최장 공통 K-부분 서열&quot; 가 상당히 많은 데 
                그 중 가장 알파벳 순으로 빠른 걸 찾기 위해,  그것들을 
                모두 탐색해서 진짜 답이 되는 한가지를 뽑아내야겠죠. </font></p>
                <p><font size="2">&nbsp;&nbsp;아까 맨 처음에 그랬듯, 두 데이터를 거꾸로 
                입력을 받아야 합니다. 동적계획법으로 배열을 다 채우고 나서 우리는 뒤에서 부터 BFS 
                탐색을 해 
                나가서 &quot;최장 공통 K-부분 서열&quot; 를 찾아내고, 나중에 뒤집어서 출력을 하는 거죠.</font></p>
                <p>
                <p><font size="2"><br>Data1 = &quot;CACTGA&quot;, <br>Data2 
                = &quot;CAGAGTAG&quot;, <br>K = 1</font></p>
<p><font size="2">&nbsp;&nbsp;이렇게 데이터가 있습니다(두 데이터들은 뒤집어 
                놓은 상태입니다). C[i, j] 값들 중 가장 큰 값을 answer 라 합시다. 
                여기서 answer 값은 3입니다. </font></p>
                <p><font size="2">&nbsp;&nbsp;일단 모든 (i, j) 에 대하여, C[i, j] = answer 
                이고 Data1[i] = Data2[j] 인 순서쌍 (i, j) 들 중에서 알파벳 순으로 
                가장 빠른 Data1[i](혹은 Data2[j])의 값을 찾습니다. 위를 예로 들자면, C[6, 7] 의 값이 
                answer 와 같고, Data1[6] = Data2[7] 이며, Data1[6] (혹은 Data2[7]) 
                값이 &quot;A&quot; 로서 가장 빠릅니다. 그 문자를 chf 라 합시다. 
                </font></p>
                <p><font size="2">&nbsp;&nbsp;그러면, 다시 모든 (i, j) 에 대하여, </font></p>
                <p><font size="2">i) C[i, j] = answer <br>ii) Data1[i] = Data2[j] 
                <br>iii) Data1[i] = chf </font></p>
                <p><font size="2">&nbsp;&nbsp;위 세 조건을 모두 만족하는 순서쌍 (i, j) 를 
                큐에 집어 넣습니다. </font></p>
                <p>&nbsp;</p>
                <p><font size="2">&nbsp;&nbsp;그리고 이제 BFS 를 시작하는데, 현재 큐에 저장된 
                순서쌍들을 대상으로 탐색을 해 나갑니다. 탐색을 하는 도중, 현재 
                위치해 있는 순서쌍을 (a, b) 라 하면, (a, b) 와 같은 레벨에 있는 
                모든 순서쌍 (i, j) 에 대하여,</font></p>
                <p><font size="2">i) C[l1, l2] = C[i, j] - 1 <br>ii) Data1[l1] 
                = Data2[l2] <br>iii) i-k-1 &lt;= l1 &lt;= i-1 <br>iv) j-k-1 
                &lt;= l2 &lt;= j-1 </font></p>
                <p><font size="2">&nbsp;&nbsp;네 조건을 만족하는 (l1, l2) 중에서 Data[l1] 
                의 값이 가장 빠른 문자를 찾아 chf 란 변수에 저장합니다. </font></p>
                <p><font size="2">&nbsp;&nbsp;이번에는 현재 위치해 있는 순서쌍을 
                (i, j) 라 치고, 다시 for 루프를 돌며 위의 네 조건을 만족하고, Data[l1] 
                = chf 라는 새로운 조건을 추가적으로 또 만족하는 그런 (l1, l2) 를 찾아서 큐에 
                집어 넣습니다. </font></p>
                <p><font size="2">&nbsp;&nbsp;위와 같이 현재보다 하위 단계의 배열로 탐색을 하되, 
                현재 보다 하위로 올 수 있는 문자들 중 가장 빠른 문자를 찾고, 
                그 문자로 시작하는 하위 단계들을 큐에 저장을 시키고, 또 그 다음으로 
                그 하위 단계들에서 BFS 탐색을 계속하는 식으로 진행을 해 나갑니다. 
                그렇게 하면 결국에는 현재 보다 하위로 올 수 있는 문자들 중 가장 
                빨랐던 그 문자들을 쭉 나열해 보면 그것이 답이 되는 겁니다.</font></p>
                <p><font size="2">&nbsp;&nbsp;주의하실 사항은 위에 설명한 그대로 
                코딩하시면 안됩니다. 약간의 기술(?)을 써서 코딩을 해야 제 시간 
                안에 나올 겁니다. 그건 코딩 하시기 전에 다시 한 번 고민해 보시기 
                바랍니다.</font></p>
                <p><font size="2">&nbsp;&nbsp;자, 이제 예제 데이터와 BFS 가 진행되는 
                단계를 그림으로 간략하게나마 보여드리겠습니다.</font></p>
                <p><font size="2"><img src="skoi02m3.jpg" width="573" height="420" border="0"></font></p>
                <p><font size="2">&nbsp;&nbsp;설명이 많이 부족하고, 언어능력-_-이 부족한 
                관계로 이해가 잘 가실지 모르겠지만, 생각을 충분히 해보셨다면 
                아하! 하고 이해가 가실 거라 생각합니다.</font></p>
</td>
        </tr>
    </table>
    <p><font size="2">&nbsp;</font></p>
</ul>
</body>

</html>