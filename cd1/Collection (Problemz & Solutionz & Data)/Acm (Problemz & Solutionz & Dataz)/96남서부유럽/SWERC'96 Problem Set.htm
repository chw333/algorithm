<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0076)http://www.acm.inf.ethz.ch/ProblemSetArchive/B_EU_SWERC/1996/problems96.html -->
<HTML><HEAD><TITLE>SWERC\'96 Problem Set</TITLE>
<META content="text/html; charset=ks_c_5601-1987" http-equiv=Content-Type>
<META content="MSHTML 5.00.3315.2870" name=GENERATOR>
<META content="" name=description>
<META content="" name=keywords>
<META content="" name=resource-type>
<META content="" name=distribution></HEAD>
<BODY bgColor=#ffffff>
<H3 align=center>1996--1997 ACM International Collegiate Programming 
Contest<BR>Southwestern European Regional Contest<BR>ETH Z&uuml;rich, November 16, 
1996<BR></H3>
<P align=center>Sponsored by <I>Microsoft<BR></I>Supported by <I>Union Bank of 
Switzerland</I><BR>
<HR>

<P></P>
<H1>Problem Set</H1>
<H3>Contents</H3>
<OL>
  <LI><A 
  href="http://www.acm.inf.ethz.ch/ProblemSetArchive/B_EU_SWERC/1996/problems96.html#Stars">Stars</A> 

  <LI><A 
  href="http://www.acm.inf.ethz.ch/ProblemSetArchive/B_EU_SWERC/1996/problems96.html#Hexagon">Hexagon</A> 

  <LI><A 
  href="http://www.acm.inf.ethz.ch/ProblemSetArchive/B_EU_SWERC/1996/problems96.html#Domino">Domino 
  Effect</A> 
  <LI><A 
  href="http://www.acm.inf.ethz.ch/ProblemSetArchive/B_EU_SWERC/1996/problems96.html#Pendulum">Pendulum</A> 

  <LI><A 
  href="http://www.acm.inf.ethz.ch/ProblemSetArchive/B_EU_SWERC/1996/problems96.html#Border">Border</A> 

  <LI><A 
  href="http://www.acm.inf.ethz.ch/ProblemSetArchive/B_EU_SWERC/1996/problems96.html#Villa">The 
  New Villa</A> 
  <LI><A 
  href="http://www.acm.inf.ethz.ch/ProblemSetArchive/B_EU_SWERC/1996/problems96.html#Ships">Ships</A> 

  <LI><A 
  href="http://www.acm.inf.ethz.ch/ProblemSetArchive/B_EU_SWERC/1996/problems96.html#Jury">Jury 
  Compromise</A> </LI></OL>
<P>
<HR>

<P></P>
<H2><A name=Stars></A>Problem A: Stars</H2>
<P>
<TABLE border=0 cellPadding=0 cellSpacing=2>
  <TBODY>
  <TR>
    <TD align=right><B>Source file:<BR>Input file:</B></TD>
    <TD><TT><FONT 
  size=+1>stars.pas/stars.c/stars.C<BR>stars.in</FONT></TT></TD></TR></TBODY></TABLE></P>
<P>On a clear moon-less night, you can see millions of stars glimmering in the 
sky. Faced with this overwhelming number, the Greeks started nearly 2,000 years 
ago to bring some order to the chaos. They identified groups of stars, called 
constellations, and gave them names, mostly from the Greek mythology, that are 
still in use today. Examples are ``Ursa Minor'', ``Pisces'', ``Cancer'', and 
many others. </P>
<P>Given a sketch of the constellation, it is not easy for the amateur to 
actually find the constellation in the sky. Moreover, simple constellations, 
such as ``Triangulum'' (triangle,) which consists of only three stars, may 
appear several times in the sky. Again, singling out the ``correct'' occurrence 
is not easy. </P>
<P>Traditionally, maps were printed for just this purpose. But in this problem, 
we will see how the computer can help us find constellations in the sky. </P>
<P>You will be given a star map; for simplicity this will be a collection of 
points in the plane, each having a certain brightness associated with it. Then, 
given a constellation, also as a set of points in the plane, you are to 
determine: </P>
<UL>
  <LI>the number of occurrences of the constellation in the star map, and 
  <LI>the position of the brightest occurrence, if one exists. (The rationale 
  behind this is as follows: if a constellation seems to appear several times in 
  the sky, the brightest one is most likely to be the real one, since it is the 
  most eye-catching one.) </LI></UL>
<P>An occurrence is a subset of stars from the map that forms a (possibly) 
arbitrarily rotated and/or scaled copy of the stars in the constellation. </P>
<P>The brightness of an occurrence is the average brightness of the stars it 
consists of, i.e. the sum of individual brightnesses divided by the number of 
stars in the constellation. </P>
<H3>Input Specification</H3>
<P>The input file contains the descriptions of several star maps. Each map 
starts with a line containing a single integer <I>n</I>, specifying the number 
of stars in the map (1 &lt;= <I>n</I> &lt; 1000). The following <I>n</I> lines 
contain three integers each, namely the <I>x</I>- and <I>y</I>-coordinates and 
the brightness of every star. The larger the value, the brighter the star 
shines. </P>
<P>The next line contains a single integer <I>m</I>, the number of 
constellations to follow (1 &lt;= <I>m</I> &lt; 50). Each constellation 
description starts with a line containing an integer <I>s<SUB><FONT 
size=-1>i</FONT></SUB></I>, the number of stars in constellation <I>i</I>, and a 
string <I>N<SUB><FONT size=-1>i</FONT></SUB></I>, the name of the constellation. 
(<I>N<SUB><FONT size=-1>i</FONT></SUB></I> will consist of no more than 40 
characters and contain no blanks.) The following <I>s<SUB><FONT 
size=-1>i</FONT></SUB></I> lines then contain the coordinates of the 
constellation, again as <I>x/y</I>-pairs. </P>
<P>A blank line separates the star map from the next map. The input file ends 
with an empty map (having <I>n</I> = 0), which should not be processed. </P>
<P><I>N.B.</I>: Since all star coordinates are integer numbers, you can easily 
rule out any rotated or scaled constellation whose points do not fall on integer 
coordinates. </P>
<H3>Output Specification</H3>
<P>For each star map first output the number of the map (<TT>`Map #1'</TT>, 
<TT>`Map #2'</TT>, etc.) on a line of its own. </P>
<P>For each constellation, in the same order as in the input, output first its 
name and how many times it occurs in the map on one line, as shown in the output 
sample. </P>
<P>If there is at least one occurrence, output the position of the brightest 
occurrence by listing the positions of the stars that form the brightest 
occurrence. The star positions have to be printed in ascending <I>x</I>-order. 
Positions having the same <I>x</I>-coordinates must be sorted in ascending 
<I>y</I>-order. If there are several equally bright solutions, output only one 
of them. Adhere to the format shown in the sample output. </P>
<P>Output a blank line before each constellation and a line of 5 dashes 
(<TT>`-----'</TT>) after every star map. </P>
<H3>Sample Input</H3><PRE>6
1 2 1
2 1 4
2 4 3
3 2 1
4 1 5
4 3 2
2
3 Triangulum
1 1
3 1
2 4
4 Cancer
1 3
4 3
6 1
7 5

0
</PRE>
<H3>Output for Sample Input</H3><PRE>Map #1

Triangulum occurs 2 time(s) in the map.
Brightest occurrence: (1,2) (4,1) (4,3)


Cancer occurs 0 time(s) in the map.

-----
</PRE>
<P>[End of Problem A]</P>
<P>
<HR>

<P></P>
<H2><A name=Hexagon></A>Problem B: Hexagon</H2>
<P>
<TABLE border=0 cellPadding=0 cellSpacing=2>
  <TBODY>
  <TR>
    <TD align=right><B>Source file:<BR>Input file:</B></TD>
    <TD><TT><FONT 
      size=+1>hexagon.pas/hexagon.c/hexagon.C<BR>hexagon.in</FONT></TT></TD></TR></TBODY></TABLE></P>
<P>Consider a game board consisting of 19 hexagonal fields, as shown in the 
figure below. We can easily distinguish three main directions in the shape of 
the board: from top to bottom, from top-left to bottom-right, and from top-right 
to bottom-left. For each of these primary directions, the board can be viewed as 
a series of rows, consisting of 3, 4, 5, 4, and 3 fields, respectively. </P>
<P align=center><IMG align=bottom height=174 
src="SWERC'96 Problem Set.files/hexagon.gif" width=161 NATURALSIZEFLAG="0"></P>
<P></P>
<P>The game board has to be completely covered using a set of hexagonal pieces. 
Each piece carries three numbers, one for every primary board direction. Only 
three different numbers are used for each direction. Every possible combination 
of three numbers for all three directions is assigned to a piece, leading to a 
set of 27 unique pieces. (The board in the above figure is still in the process 
of being covered.) </P>
<P>The score of a board is calculated as the sum of all 15 row scores (5 rows 
for each primary direction). The row scores are calculated as follows: if all 
pieces in a row carry the same number for the direction of the row, the row 
score is this number multiplied by the number of pieces in the row. Otherwise 
(the pieces carry different numbers in the row direction) the row score is zero. 
Note that the pieces may not be rotated. For example, the score of the leftmost 
row in the figure is 3 <SUP>.</SUP> 3 = 9, the score of the row to its right is 
4 <SUP>.</SUP> 11 = 44. </P>
<P>While in the real game the pieces are chosen randomly and the set of pieces 
is fixed, we are interested in the highest possible score for a given set of 
numbers for each direction. This means you have to choose those 19 pieces that 
result in the highest score. </P>
<H3>Input Specification</H3>
<P>The first line of the input file contains an integer <B>n</B> which indicates 
the number of test cases. Each test case consists of three lines containing 
three integers each. Each of these three line contains the numbers for a single 
primary direction. From these numbers the set of pieces is generated. </P>
<H3>Output Specification</H3>
<P>For each test case output a line containing the number of the case (<TT>`Test 
#1'</TT>, <TT>`Test #2'</TT>, etc.), followed by a line containing the highest 
possible score for the given numbers. Add a blank line after each test case. 
</P>
<H3>Sample Input</H3><PRE>1
9 4 3
8 5 2
7 6 1
</PRE>
<H3>Output for Sample Input</H3><PRE>Test #1
308
</PRE>
<P>[End of Problem B]</P>
<P><I>The following clarification was added to the problem during the last 
minute announcements:<BR></I>To simplify the problem, you should only consider 
boards where each row has a score greater than zero, i.e. each piece in a row 
carries the same number.</P>
<P>
<HR>

<P></P>
<H2><A name=Domino></A>Problem C: Domino Effect</H2>
<P>
<TABLE border=0 cellPadding=0 cellSpacing=2>
  <TBODY>
  <TR>
    <TD align=right><B>Source file:<BR>Input file:</B></TD>
    <TD><TT><FONT 
    size=+1>domino.pas/domino.c/domino.C<BR>domino.in</FONT></TT></TD></TR></TBODY></TABLE></P>
<P>Did you know that you can use domino bones for other things besides playing 
Dominoes? Take a number of dominoes and build a row by standing them on end with 
only a small distance in between. If you do it right, you can tip the first 
domino and cause all others to fall down in succession (this is where the phrase 
``domino effect'' comes from). </P>
<P>While this is somewhat pointless with only a few dominoes, some people went 
to the opposite extreme in the early Eighties. Using millions of dominoes of 
different colors and materials to fill whole halls with elaborate patterns of 
falling dominoes, they created (short-lived) pieces of art. In these 
constructions, usually not only one but several rows of dominoes were falling at 
the same time. As you can imagine, timing is an essential factor here. </P>
<P>It is now your task to write a program that, given such a system of rows 
formed by dominoes, computes when and where the last domino falls. The system 
consists of several ``key dominoes'' connected by rows of simple dominoes. When 
a key domino falls, all rows connected to the domino will also start falling 
(except for the ones that have already fallen). When the falling rows reach 
other key dominoes that have not fallen yet, these other key dominoes will fall 
as well and set off the rows connected to them. Domino rows may start collapsing 
at either end. It is even possible that a row is collapsing on both ends, in 
which case the last domino falling in that row is somewhere between its key 
dominoes. You can assume that rows fall at a uniform rate. </P>
<H3>Input Specification</H3>
<P>The input file contains descriptions of several domino systems. The first 
line of each description contains two integers: the number <I>n</I> of key 
dominoes (1 &lt;= <I>n</I> &lt; 500) and the number <I>m</I> of rows between 
them. The key dominoes are numbered from 1 to <I>n</I>. There is at most one row 
between any pair of key dominoes and the domino graph is connected, i.e. there 
is at least one way to get from a domino to any other domino by following a 
series of domino rows. </P>
<P>The following <I>m</I> lines each contain three integers <I>a</I>, <I>b</I>, 
and <I>l</I>, stating that there is a row between key dominoes <I>a</I> and 
<I>b</I> that takes <I>l</I> seconds to fall down from end to end. </P>
<P>Each system is started by tipping over key domino number <I>1</I>. </P>
<P>The file ends with an empty system (with <I>n</I> = <I>m</I> = 0), which 
should not be processed. </P>
<H3>Output Specification</H3>
<P>For each case output a line stating the number of the case (<TT>`System 
#1'</TT>, <TT>`System #2'</TT>, etc.). Then output a line containing the time 
when the last domino falls, exact to one digit to the right of the decimal 
point, and the location of the last domino falling, which is either at a key 
domino or between two key dominoes. Adhere to the format shown in the output 
sample. If you find several solutions, output only one of them. Output a blank 
line after each system. </P>
<H3>Sample Input</H3><PRE>2 1
1 2 27
3 3
1 2 5
1 3 5
2 3 5
0 0
</PRE>
<H3>Output for Sample Input</H3><PRE>System #1
The last domino falls after 27.0 seconds, at key domino 2.


System #2
The last domino falls after 7.5 seconds, between key dominoes 2 and 3.
</PRE>
<P>[End of Problem C]</P>
<P>
<HR>

<P></P>
<H2><A name=Pendulum></A>Problem D: Pendulum</H2>
<P>
<TABLE border=0 cellPadding=0 cellSpacing=2>
  <TBODY>
  <TR>
    <TD align=right><B>Source file:<BR>Input file:</B></TD>
    <TD><TT><FONT 
      size=+1>pendulum.pas/pendulum.c/pendulum.C<BR>pendulum.in</FONT></TT></TD></TR></TBODY></TABLE></P>
<P>Consider a pendulum hanging on a string from a hook on a wall. When pushed, 
this pendulum will swing back and forth. Now imagine other hooks on the wall, 
placed in the path of our pendulum's string. The pendulum will bend around them, 
possibly even loop around them. In general, it will follow a much more complex 
path than before. After some time, the pendulum's motion will repeat, the 
pendulum will follow a <I>periodic orbit</I>. What we would like you to do is to 
compute the distance travelled by the pendulum as it completes one cycle of the 
orbit. </P>
<P>More formally, we place a cartesian coordinate system on the wall. The 
pendulum's string is affixed at the origin (0, 0). As usual, the <I>x</I>-axis 
points to the right and the <I>y</I>-axis points upwards. The string of the 
pendulum has a length of <I>r</I>. The pendulum is released at position 
(-<I>r</I>, 0) and therefore starts swinging to the right. Furthermore, there 
are <I>n</I> additional hooks distributed over the plane which may influence the 
path of the pendulum. </P>
<P>In our ideal world, the following assumptions are true: </P>
<UL>
  <LI>The diameters of the hooks and of the string are zero. 
  <LI>The pendulum loses no energy (e.g. by friction). 
  <LI>The pendulum will never hit a hook, only its string will. 
  <LI>The pendulum's string is made of some futuristic material that only bends 
  where it touches a hook but is otherwise rigid. </LI></UL>
<P>Your program should simulate the movement of the pendulum and output the 
spatial length of the periodic orbit that it finally enters. As you may remember 
from physics: due to gravity, the pendulum will never reach a height greater 
than the one it started from! That is, it will never get above the 
<I>x</I>-axis. It will either reach its initial height again or circle endlessly 
around a hook in the wall. </P>
<H3>Input Specification</H3>
<P>The input file contains several test cases. Each case begins with a line 
containing an integer <I>n</I> (the number of hooks, 1 &lt;= <I>n</I> &lt; 500) 
and a real <I>r</I> (the length of the pendulum's string). The following 
<I>n</I> lines each contain two integers specifying the <I>x</I>- and 
<I>y</I>-coordinate of the corresponding hook. </P>
<P>The file ends with a case having <I>r</I> = 0, which should not be processed. 
</P>
<H3>Output Specification</H3>
<P>For each case output a line containing the number of the case (<TT>`Pendulum 
#1'</TT>, <TT>`Pendulum #2'</TT>, etc.). </P>
<P>Then print a line that contains the distance which the pendulum travels for 
completing one cycle of its periodic orbit. Do not count the distance travelled 
to reach the starting point of the orbit. (Adhere to the format shown in the 
output sample.) The distance should be exact to two digits to the right of the 
decimal point. </P>
<P>Output a blank line after each test case. </P>
<H3>Sample Input</H3><PRE>2 16.0
3 -4
-3 -4
1 18.0
5 -12
0 0
</PRE>
<H3>Output for Sample Input</H3><PRE>Pendulum #1
Length of periodic orbit = 87.66


Pendulum #2
Length of periodic orbit = 31.42
</PRE>
<P>[End of Problem D]</P>
<P>
<HR>

<P></P>
<H2><A name=Border></A>Problem E: Border</H2>
<P>
<TABLE border=0 cellPadding=0 cellSpacing=2>
  <TBODY>
  <TR>
    <TD align=right><B>Source file:<BR>Input file:</B></TD>
    <TD><TT><FONT 
    size=+1>border.pas/border.c/border.C<BR>border.in</FONT></TT></TD></TR></TBODY></TABLE></P>
<P>You are to write a program that draws a border around a closed path into a 
bitmap, as displayed in the following figure: </P>
<P align=center><IMG align=bottom height=203 
src="SWERC'96 Problem Set.files/border.gif" width=202 NATURALSIZEFLAG="0"></P>
<P></P>
<P>The path is closed and runs along the grid lines, i.e. between the squares of 
the grid. The path runs counter-clockwise, so if following the path is 
considered as going ``forward'', the border pixels are always to the ``right'' 
of the path. The bitmap always covers 32 by 32 squares and has its lower left 
corner at (0, 0). You can safely assume that the path never touches the bounding 
rectangle of the bitmap and never touches or crosses itself. Note that a bit 
gets set if it is on the outside of the area surrounded by the path and if at 
least one of its edges belongs to the path, but not if only one of its corners 
is in the path. (A look at the convex corners in the figure should clarify that 
statement.) </P>
<H3>Input Specification</H3>
<P>The first line of the input file contains the number of test cases in the 
file. Each test case that follows consists of two lines. The first line of each 
case contains two integer numbers <I>x</I> and <I>y</I> specifying the starting 
point of the path. The second line contains a string of variable length. Every 
letter in the string symbolizes a move of length one along the grid. Only the 
letters <TT>`W'</TT> (``west''), <TT>`E'</TT> (``east''), <TT>`N'</TT> 
(``north''), <TT>`S'</TT> (``south''), and <TT>`.'</TT> (``end of path'', no 
move) appear in the string. The end-of-path character (<TT> `.'</TT>) is 
immediately followed by the end of the line. </P>
<H3>Output Specification</H3>
<P>For each test case, output a line with the number of the case (<TT>`Bitmap 
#1'</TT>, <TT>`Bitmap #2'</TT>, etc.). For each row of the bitmap from top to 
bottom, print a line where you print a character for every bit in that row from 
left to right. Print an uppercase <TT>`X'</TT> for set bits and a period 
<TT>`.'</TT> for unset bits. Output a blank line after each bitmap. </P>
<H3>Sample Input</H3><PRE>1
2 1
EENNWNENWWWSSSES.
</PRE>
<H3>Output for Sample Input</H3>
<P><TT>Bitmap #1<BR>................................<BR><B><I>&lt;</I></B><I>24 
lines of periods 
omitted<B>&gt;<BR></B></I>................................<BR>.XXX............................<BR>X...X...........................<BR>X..X............................<BR>X...X...........................<BR>.X..X...........................<BR>..XX............................ 
</TT></P>
<P>[End of Problem E]</P>
<P>
<HR>

<P></P>
<H2><A name=Villa></A>Problem F: The New Villa</H2>
<P>
<TABLE border=0 cellPadding=0 cellSpacing=2>
  <TBODY>
  <TR>
    <TD align=right><B>Source file:<BR>Input file:</B></TD>
    <TD><TT><FONT 
  size=+1>villa.pas/villa.c/villa.C<BR>villa.in</FONT></TT></TD></TR></TBODY></TABLE></P>
<P>Mr. Black recently bought a villa in the countryside. Only one thing bothers 
him: although there are light switches in most rooms, the lights they control 
are often in other rooms than the switches themselves. While his estate agent 
saw this as a feature, Mr. Black has come to believe that the electricians were 
a bit absent-minded (to put it mildly) when they connected the switches to the 
outlets. </P>
<P>One night, Mr. Black came home late. While standing in the hallway, he noted 
that the lights in all other rooms were switched off. Unfortunately, Mr. Black 
was afraid of the dark, so he never dared to enter a room that had its lights 
out and would never switch off the lights of the room he was in. </P>
<P>After some thought, Mr. Black was able to use the incorrectly wired light 
switches to his advantage. He managed to get to his bedroom and to switch off 
all lights except for the one in the bedroom. </P>
<P>You are to write a program that, given a description of a villa, determines 
how to get from the hallway to the bedroom if only the hallway light is 
initially switched on. You may never enter a dark room, and after the last move, 
all lights except for the one in the bedroom must be switched off. If there are 
several paths to the bedroom, you have to find the one which uses the smallest 
number of steps, where ``move from one room to another'', ``switch on a light'' 
and ``switch off a light'' each count as one step. </P>
<H3>Input Specification</H3>
<P>The input file contains several villa descriptions. Each villa starts with a 
line containing three integers <I>r</I>, <I>d</I>, and <I>s</I>. <I>r</I> is the 
number of rooms in the villa, which will be at most 10. <I>d</I> is the number 
of doors/connections between the rooms and <I>s</I> is the number of light 
switches in the villa. The rooms are numbered from 1 to <I>r</I>; room number 1 
is the hallway, room number <I>r</I> is the bedroom. </P>
<P>This line is followed by <I>d</I> lines containing two integers <I>i</I> and 
<I>j</I> each, specifying that room <I>i</I> is connected to room <I>j</I> by a 
door. Then follow <I>s</I> lines containing two integers <I>k</I> and <I>l</I> 
each, indicating that there is a light switch in room <I>k</I> that controls the 
light in room <I>l</I>. </P>
<P>A blank line separates the villa description from the next one. The input 
file ends with a villa having <I>r</I> = <I>d</I> = <I>s</I> = 0, which should 
not be processed. </P>
<H3>Output Specification</H3>
<P>For each villa, first output the number of the test case (<TT>`Villa 
#1'</TT>, <TT>`Villa #2'</TT>, etc.) in a line of its own. </P>
<P>If there is a solution to Mr. Black's problem, output the shortest possible 
sequence of steps that leads him to his bedroom and only leaves the bedroom 
light switched on. (Output only one shortest sequence if you find more than 
one.) Adhere to the output format shown in the sample below. </P>
<P>If there is no solution, output a line containing the statement <TT>`The 
problem cannot be solved.'</TT> </P>
<P>Output a blank line after each test case. </P>
<H3>Input Sample</H3><PRE>3 3 4
1 2
1 3
3 2
1 2
1 3
2 1
3 2

2 1 2
2 1
1 1
1 2

0 0 0
</PRE>
<H3>Output for Input Sample</H3><PRE>Villa #1

The problem can be solved in 6 steps:
 - Switch on light in room 2.
 - Switch on light in room 3.
 - Move to room 2.
 - Switch off light in room 1.
 - Move to room 3.
 - Switch off light in room 2.


Villa #2
The problem cannot be solved.
</PRE>
<P>[End of Problem F]</P>
<P>
<HR>

<P></P>
<H2><A name=Ships></A>Problem G: Ships</H2>
<P>
<TABLE border=0 cellPadding=0 cellSpacing=2>
  <TBODY>
  <TR>
    <TD align=right><B>Source file:<BR>Input file:</B></TD>
    <TD><TT><FONT 
  size=+1>ships.pas/ships.c/ships.C<BR>ships.in</FONT></TT></TD></TR></TBODY></TABLE></P>
<P>Probably everyone who ever attended school knows the game where two opposing 
players place a set of ships on a sheet of paper and try to eliminate each 
other's ships by guessing their location. </P>
<P>In our version of the game, your opponent has distributed the following seven 
ship patterns over a rectangular grid of squares:</P>
<P><TT>xx &nbsp;xx &nbsp;&nbsp;&nbsp;xx 
&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x &nbsp;&nbsp;x<BR>xx &nbsp;&nbsp;xx 
&nbsp;xx&nbsp;&nbsp;&nbsp;xxx&nbsp;&nbsp;xxx&nbsp;&nbsp;xxx&nbsp;&nbsp;xxxx</TT></P>
<P>Each ship pattern covers exactly four squares. The patterns may be rotated 
but not mirrored. All patterns are guaranteed to be placed completely within the 
boundaries of the rectangle and not to overlap each other, whereas touching 
another pattern or the border is allowed. </P>
<P>We assume that we are in the middle of the game and that several squares have 
already been uncovered. You will be given a rectangular grid of squares 
representing your current knowledge about the positions of your enemy's ships. 
Every square is marked by one of the following characters: </P>
<UL>
  <LI><TT>`x'</TT> if a ship covers the square 
  <LI><TT>`o'</TT> if no ship covers the square 
  <LI><TT>`.'</TT> if the square has not yet been uncovered </LI></UL>
<P>Given that information, you are to decide whether you can determine all 
remaining <TT>`x'</TT> squares with at most one miss, i.e. whether you could 
uncover the <TT>`.'</TT> squares without getting more than one <TT>`o'</TT> 
square before you had all <TT>`x'</TT> squares uncovered. This means you are 
allowed to hit a <TT>`o'</TT> if then the solution becomes unique. </P>
<H3>Input Specification</H3>
<P>The input file contains several game situations. Every test case starts with 
a line containing two integers <I>w</I> and <I>h</I>. These define width and 
height of the game rectangle, where 2 &lt;= <I>w, h</I> &lt;= 16. </P>
<P>Each of the next <I>h</I> lines contains a string of <I>w</I> characters. 
Each of these characters is either <TT>`x'</TT>, <TT>`o'</TT> or <TT>`.'</TT>, 
depending on the state of the corresponding square. </P>
<P>A blank line separates each game from the next. The input file ends with a 
game having <I>w</I> = 0 and <I>h</I> = 0. This game should not be processed. 
</P>
<H3>Output Specification</H3>
<P>For each test case you should first output a line containing the number of 
the game, followed by a line containing either <TT>`yes.'</TT> (if you can 
determine all <TT>`x'</TT> with at most one miss) or <TT>`no.'</TT> (if you 
cannot determine all <TT>`x'</TT> without at least two misses). </P>
<P>Output a blank line after every game. </P>
<H3>Sample Input</H3><PRE>10 10
.x..x.....
oooooxoooo
oxooxxx...
xxoooooo..
xoooxooo..
ooxxxxoo..
oooooxxoox
ooooooxoox
ooooooooxx
oooooooooo


0 0
</PRE>
<H3>Output for Sample Input</H3><PRE>Game #1
yes.
</PRE>
<P>[End of Problem G]</P>
<P>
<HR>

<P></P>
<H2><A name=Jury></A>Problem H: Jury Compromise</H2>
<P>
<TABLE border=0 cellPadding=0 cellSpacing=2>
  <TBODY>
  <TR>
    <TD align=right><B>Source file:<BR>Input file:</B></TD>
    <TD><TT><FONT 
  size=+1>jury.pas/jury.c/jury.C<BR>jury.in</FONT></TT></TD></TR></TBODY></TABLE></P>
<P>In Frobnia, a far-away country, the verdicts in court trials are determined 
by a jury consisting of members of the general public. Every time a trial is set 
to begin, a jury has to be selected, which is done as follows. First, several 
people are drawn randomly from the public. For each person in this pool, defence 
and prosecution assign a grade from 0 to 20 indicating their preference for this 
person. 0 means total dislike, 20 on the other hand means that this person is 
considered ideally suited for the jury. </P>
<P>Based on the grades of the two parties, the judge selects the jury. In order 
to ensure a fair trial, the tendencies of the jury to favour either defence or 
prosecution should be as balanced as possible. The jury therefore has to be 
chosen in a way that is satisfactory to both parties. </P>
<P>We will now make this more precise: given a pool of <I>n</I> potential jurors 
and two values <I>d<SUB><FONT size=-1>i</FONT></SUB></I> (the defence's value) 
and <I>p<SUB><FONT size=-1>i</FONT></SUB></I> (the prosecution's value) for each 
potential juror <I>i</I>, you are to select a jury of <I>m</I> persons. If <I>J 
</I>is a subset of {1,...,<I>n</I>} with <I>m</I> elements, then <I>D(J)</I> = 
sum<SUB><I>k</I> in <I>J </I></SUB><I>d<SUB>k</SUB></I> and <I>P(J)</I> = 
sum<SUB><I>k</I> in <I>J </I></SUB><I>p<SUB>k</SUB></I> are the total values of 
this jury for defence and prosecution. </P>
<P>For an optimal jury <I>J</I>, the value |<I>D(J)</I> - <I>P(J)</I>| must be 
minimal. If there are several jurys with minimal |<I>D(J)</I> - <I>P(J)</I>|, 
one which maximizes <I>D(J)</I> + <I>P(J)</I> should be selected since the jury 
should be as ideal as possible for both parties. </P>
<P>You are to write a program that implements this jury selection process and 
chooses an optimal jury given a set of candidates. </P>
<P><I>Note</I>: If your solution is based on an inefficient algorithm, it may 
not execute in the allotted time. </P>
<H3>Input Specification</H3>
<P>The input file contains several jury selection rounds. Each round starts with 
a line containing two integers <I>n</I> and <I>m</I>. <I>n</I> is the number of 
candidates and <I>m</I> the number of jury members. These values will satisfy 1 
&lt;= <I>n</I> &lt;= 200, 1 &lt;= <I>m</I> &lt;= 20 and of course <I>m</I> &lt;= 
<I>n</I>. The following <I>n</I> lines contain the two integers <I>p<SUB><FONT 
size=-1>i</FONT></SUB></I>and <I>d<SUB><FONT size=-1>i </FONT></SUB></I>for 
<I>i</I> = 1,...,<I>n</I>. A blank line separates each round from the next. </P>
<P>The file ends with a round that has <I>n</I> = <I>m</I> = 0. </P>
<H3>Output Specification</H3>
<P>For each round output a line containing the number of the jury selection 
round (<TT>`Jury #1'</TT>, <TT>`Jury #2'</TT>, etc.). </P>
<P>On the next line print the values <I>D(J)</I> and <I>P(J)</I> of your jury as 
shown below and on another line print the numbers of the <I>m</I> chosen 
candidates in ascending order. Output a blank before each individual candidate 
number. </P>
<P>Output an empty line after each test case. </P>
<H3>Sample Input</H3><PRE>4 2
1 2
2 3
4 1
6 2


0 0
</PRE>
<H3>Output for Sample Input</H3><PRE>Jury #1
Best jury has value 6 for prosecution and value 4 for defence:
 2 3
</PRE>
<P>[End of Problem H]<BR>
<HR>

<P></P>
<P><A href="http://www.acm.inf.ethz.ch/"><I>Home Page</I></A><I>. <A 
href="mailto:acm@iet.ethz.ch">Comments</A>. Last update: November 28, 1996 
(eos). </I></P></BODY></HTML>
