<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Buffer Manager</title>
<style xml:space="preserve"> h1 { text-align: center; font-size: large; text-decoration: underline }  h2 { text-align: center; font-size: large; margin-bottom: 0 } </style></head>
<body>

<h1>2000-2001 ACM Northeastern European Regional Programming Contest</h1><h2>Problem B<br></br>&quot;Buffer Manager&quot;</h2>

<table>
<tr><td colspan="1" rowspan="1"><strong>Input file</strong></td><td colspan="1" rowspan="1"><tt>BUFFER.IN</tt></td></tr>
<tr><td colspan="1" rowspan="1"><strong>Output file</strong></td><td colspan="1" rowspan="1"><tt>BUFFER.OUT</tt></td></tr>
<tr><td colspan="1" rowspan="1"><strong>Time limit</strong></td><td colspan="1" rowspan="1">15 seconds per test</td></tr>
</table>

<p>
DBMS (Data Base Management System) development team has
been successful in designing efficient Lock Manager and
is going to proceed further. As a part of the team you will
be responsible for the <strong>Buffer Manager</strong>.</p>

<p>
<strong>Data blocks</strong> being read by DBMS from the hard drive
are stored in the main memory
in a fixed number of pre-allocated <strong>buffers</strong>. 
Each buffer can hold one  data block.
Each buffer can be either <strong>free</strong>
(does not contain any useful information) or <strong>occupied</strong> by some data.
When DBMS is going to read data block from the hard drive it has 
to decide which buffer to use for data storing.
If there 
are any free buffers, then one of them is used for that purpose.
If there are no free buffers, then one of the occupied buffers
has to be flushed to become free, unless it was <strong>locked</strong> by  
some part of DBMS.</p>

<p>
The choice of the buffer to flush is critical to DBMS performance.
A lot of different algorithms were developed, LRU (Least Recently
Used) algorithm being the
one used most often. However, your DBMS is
going to implement the Advanced Buffer Management algorithm
which takes advantage
of the fact  that maximal
performance is achieved when
a number of consecutive data blocks from the hard drive are read
into consecutive memory buffers.
</p>

<p>
Buffers are numbered from 1 to <em>N</em>, where <em>N</em>
(1&nbsp;&le;&nbsp;<em>N</em>&nbsp;&le;&nbsp;100000)
is a total number of buffers.
Each buffer can be in any one of the following states:
free, occupied or locked. 
Each occupied
buffer is assigned an integer number from 1 to 9 &ndash;
the <strong>worthiness</strong> of
the currently stored information in that
buffer. The worthiness of 
free buffers is considered to be zero. Locked buffers cannot be 
neither used nor flushed and their worthiness is undefined.</p>

<p>
Having received the request to read <em>K</em>
(1&nbsp;&le;&nbsp;<em>K</em>&nbsp;&le;&nbsp;10000)
data blocks from the hard drive, Buffer Manager has to choose
<em>K</em> consecutive non-locked
buffers numbered from <em>L</em> to 
<em>L</em>+<em>K</em>-1 that have minimal possible sum of their
worthiness, or to report that it is impossible to find <em>K</em>
consecutive non-locked buffers. The latter can also happen 
if total number of buffers is less than <em>K</em>.
</p>

<p>
Your task is to write a program that models the processing
of one request to Buffer Manager using the above algorithm.</p>

<h3>Input</h3>

<p>
The first line of the input file contains two integers,
<em>N</em> and <em>K</em>, separated by a space.</p>

<p>
Starting from the second line there is a description of a buffers' state.
The state of each buffer is represented by a single character:</p>

<ul>
  <li><strong><tt>0</tt></strong> &ndash; when the corresponding buffer is free.</li>
  <li><strong><tt>1</tt></strong> &ndash; when the corresponding buffer is occupied 
         and has worthiness of 1.</li>
  <li><strong><tt>2</tt></strong> &ndash; when the corresponding buffer is occupied
         and has worthiness of 2.</li>
  <li>...</li>
  <li><strong><tt>9</tt></strong> &ndash; when the corresponding buffer is occupied
         and has worthiness of 9.</li>
  <li><strong><tt>*</tt></strong> &ndash; when the corresponding buffer is locked.</li>
</ul>

<p>
Those characters are situated on the consecutive lines grouped
by 80 
characters per line without any spaces. Thus, each line starting
from the second one contains exactly 80 characters with a possible exception
for the last line.</p>

<h3>Output</h3>

<p>
Write to the output file the single integer number <em>L</em>.
This number gives the buffer number where first of the
<em>K</em> 
blocks from the hard drive shall be read to ensure the minimal
possible total worthiness of the blocks that
have to be flushed. 
If there are more than one such value for <em>L</em>,
then write the smallest one.
</p>

<p>
Write to the output file a single number 0 if it's impossible to find
<em>K</em> consecutive non-locked buffers.</p>

<h3>Sample input #1</h3>

<pre xml:space="preserve"><tt>100 53
2165745216091853477755800393859785807207523169954341**7363*9*94664808*4777717089
09825185827659480548</tt></pre>

<h3>Output for the sample input #1</h3>

<pre xml:space="preserve"><tt>0</tt></pre>

<h3>Sample input #2</h3>

<pre xml:space="preserve"><tt>100 10
2165745216091853477755800393859785807207523169954341**7363*9*94664808*4777717089
09825185827659480548</tt></pre>

<h3>Output for the sample input #2</h3>

<pre xml:space="preserve"><tt>36</tt></pre>

</body>
</html>