void main() 
{ 
    int list[100] 
    qsort(list, 50, sizeof(list[0]), sortf); 
} 

1. qsort를 사용하기 위해서는 정렬하기 위한 배열을 마련한다. 
위 예에서는 int형의 100개의 데이터가 가능한 배열을 설정하였다. 
qsort의 첫번째 인수에 정렬하려고 하는 데이터 배열을 전달한다. 

2. 배열 중에서 정렬하려고 하는 개수를 두번째 인수로 전달한다. 
위 예에서 50을 넣었다. 이것은 배열이 100개의 데이터를 받을 수 있지만, 프로그램에서 50개의 데이터만 정렬하려고 할 때를 의미한다. 

3. 세번째 인수는 정렬하는 하나의 크기를 전달해야 한다. 
만약, 정렬하려는 배열이 int가 아니고 float라고 생각해보자. 그러면, float형의 크기를 넣어주어야 하는데, 
위의 예에서 sizeof(list[0])이라고 쓴 것은 int형이나 float형이나 알아서 자동으로 크기를 전달해 주므로, 
훨씬 사용하기 쉽다. 

4. 네번째 인수는 정렬하는 함수를 정의한다. 
정렬함수는 main()함수 위에 선언되어 있어야 한다. 
위의 예에서 sortf함수를 다음과 같이 만들어 줄 수 있다. 

int sortf(const void *a, const void *b) 
{ 
    int *p=(int *)a, *q=(int *)b; 
    if( *p > *q ) return 1; 
    if( *p < *q ) return -1; 
    return 0; 
} 

const void *a, const void *b는 정렬하는 데이터의 형이 무엇인지 모른기 때문이다. 
따라서, 프로그래머가 정렬하려고 하는 데이터의 형을 가르쳐 주어야 하며, 
int *p=(int *)a로 형변환하여 정렬하려는 데이터의 형을 가르쳐 준다. 
이러한 방법으로 프로그래머에게 자유권을 주었으므로, qsort함수를 사용하여 어떤 데이터도 정렬 할 수 있다. 

만약에 list가 float형이라면 
sortf함수에서 
int *p=(int *)a, *q=(int *)b를 float *p=(float *)a, *q=(float *)b로 바꾸면 된다. 
이것은 앞의 데이터와 뒤의 데이터 중에서 누가 더 큰지를 넘겨 주는 것으므로 
if문의 부분을 return (*p-*q);로 한 줄로 바꿀 수도 있다. 

위의 예제는 tc를 실행한 후에 qsort 도움말을 찾아 보면 된다. 

5. 만약에 일반 배열이 아닌 struct형의 배열을 정렬하고자 할 때는 
다음과 같이 하면 된다. 
struct POINT { 
   int x,y; 
} list[MAX]; 

qsort(list, 50, sizeof(list[0]), sortf); 
list는 정렬하고자 하는 배열의 포인터이고, 
50은 정렬하려는 개수(이때 50은 struct단위의 50이다)이고, 
sizeof(list[0])은 정렬하는 단위이다. 

sortf에서는 
int sortf(const void *a, const void *b) 
{ 
    struct  POINT *p=(struct POINT *)a, *q=(struct POINT *)b; 
    if( p->x > q->x ) return 1; 
    if( p->x < q->x ) return -1; 
    return 0; 
} 
로 하면 된다. 
