#include <fstream.h>

int hx1[300], hx2[300], hy[300], nh;
int vx[300], vy1[300], vy2[300], nv;

int x[500], y[500], nx, ny;

int fleft, fright, ftop, fbottom;

long area[3000];
int narea;
char v[12500]; // 300 * 300 / 8

void swap(int &t1, int &t2)
{
	int t = t1; t1 = t2; t2 = t;
}

void swap(long &t1, long &t2)
{
	long t = t1; t1 = t2; t2 = t;
}

void input()
{
	ifstream fin("area.in");
	int nn;
	fin >> fleft >> fright >> ftop >> fbottom;
	fin >> nn;
	nh = nv = nx = ny = 2;
	hx1[0] = fleft; hx2[0] = fright; hy[0] = ftop;
	hx1[1] = fleft; hx2[1] = fright; hy[1] = fbottom;
	vx[0] = fleft; vy1[0] = ftop; vy2[0] = fbottom;
	vx[1] = fright; vy1[1] = ftop; vy2[1] = fbottom;
	x[0] = fleft; x[1] = fright; y[0] = ftop; y[1] = fbottom;
	int i;
	for(i = 0; i < nn; i++)
	{
		int x1, y1, x2, y2;
		fin >> x1 >> y1 >> x2 >> y2;
		if(x1 > x2) swap(x1, x2);
		if(y1 > y2) swap(y1, y2);
		if(x1 == x2)
		{
			vx[nv] = x1; vy1[nv] = y1; vy2[nv++] = y2;
			x[nx++] = x1; y[ny++] = y1; y[ny++] = y2;
		}
		else
		{
			hx1[nh] = x1; hx2[nh] = x2; hy[nh++] = y1;
			x[nx++] = x1; x[nx++] = x2; y[ny++] = y1;
		}
	}
}

void quicksort(int a[], int n)
{
	if(n > 1)
	{
		int l, r, kk;
		l = -1; r = n-1; kk = a[n-1];
		while(1)
		{
			while(a[++l] < kk);
			while(a[--r] > kk);
			if(l >= r) break;
			swap(a[l], a[r]);
		}
		swap(a[l], a[n-1]);
		quicksort(a, l);
		quicksort(a+l+1, n-l-1);
	}
}

void preproc()
{
	quicksort(x, nx);
	quicksort(y, ny);
	int i, j, k;
	for(i = 0; i < nx; i++)
	{
		j = i; while(x[++j] == x[i] && j != nx); j--;
		for(k = i+1; k < nx-j+i; k++)
			x[k] = x[k+j-i];
		nx -= j-i;
	}
	for(i = 0; i < ny; i++)
	{
		j = i; while(y[++j] == y[i] && j != ny); j--;
		for(k = i+1; k < ny-j+i; k++)
			y[k] = y[k+j-i];
		ny -= j-i;
	}
}

void bfs(int starty, int startx)
{
	int i;
	int qx[2000]={0,}, qy[2000]={0,}, h, t;
	h = t = 0;
	qx[t] = startx; qy[t++] = starty;
	v[(qy[h]*300l+qx[h])/8] |= (1<<(qy[h]*300l+qx[h])%8);

	while(h < t)
	{
		int x1, y1, x2, y2;
		x1 = x[qx[h]]; y1 = y[qy[h]];
		x2 = x[qx[h]+1]; y2 = y[qy[h]+1];
		area[narea] += (long)(x2-x1) * (y2-y1);

		int flag;
		if(qx[h]+1 < (nx-1) &&
		   (v[(qy[h]*300l+qx[h]+1)/8] & (1<<(qy[h]*300l+qx[h]+1)%8)) == 0)
		{
			flag = 0;
			for(i = 0; i < nv; i++)
				if(x2 == vx[i] && vy1[i] <= y1 && y2 <= vy2[i]) { flag = 1; break; }
			if(flag == 0)
			{
				qx[t] = qx[h] + 1;
				qy[t] = qy[h];
				v[(qy[t]*300l+qx[t])/8] |= (1<<(qy[t]*300l+qx[t])%8);
				t++;
			}
		}

		if(qy[h]+1 < (ny-1) &&
		   (v[((qy[h]+1)*300l+qx[h])/8] & (1<<((qy[h]+1)*300l+qx[h])%8)) == 0)
		{
			flag = 0;
			for(i = 0; i < nh; i++)
				if(y2 == hy[i] && hx1[i] <= x1 && x2 <= hx2[i]) { flag = 1; break; }
			if(flag == 0)
			{
				qx[t] = qx[h];
				qy[t] = qy[h] + 1;
				v[(qy[t]*300l+qx[t])/8] |= (1<<(qy[t]*300l+qx[t])%8);
				t++;
			}
		}

		if(qx[h] > 0 &&
		   (v[(qy[h]*300l+qx[h]-1)/8] & (1<<(qy[h]*300l+qx[h]-1)%8)) == 0)
		{
			flag = 0;
			for(i = 0; i < nv; i++)
				if(x1 == vx[i] && vy1[i] <= y1 && y2 <= vy2[i]) { flag = 1; break; }
			if(flag == 0)
			{
				qx[t] = qx[h] - 1;
				qy[t] = qy[h];
				v[(qy[t]*300l+qx[t])/8] |= (1<<(qy[t]*300l+qx[t])%8);
				t++;
			}
		}

		if(qy[h] > 0 &&
			(v[((qy[h]-1)*300l+qx[h])/8] & (1<<((qy[h]-1)*300l+qx[h])%8)) == 0)
		{
			flag = 0;
			for(i = 0; i < nh; i++)
				if(y1 == hy[i] && hx1[i] <= x1 && x2 <= hx2[i]) { flag = 1; break; }
			if(flag == 0)
			{
				qx[t] = qx[h];
				qy[t] = qy[h] - 1;
				v[(qy[t]*300l+qx[t])/8] |= (1<<(qy[t]*300l+qx[t])%8);
				t++;
			}
		}

		h++;
	}
	narea++;
}

void process()
{
	int i, j;

	for(i = 0; i < ny-1; i++)
		for(j = 0; j < nx-1; j++)
			if((v[(i*300l+j)/8] & (1<<(i*300l+j)%8)) == 0)
				bfs(i, j);
}

void quicksort2(int left, int right)
{
	if(left+1 < right)
	{
		int l = left-1, r = right-1;
		long kk = area[right-1];
		while(1)
		{
			while(area[++l] < kk);
			while(area[--r] > kk);
			if(l >= r) break;
			swap(area[l], area[r]);
		}
		swap(area[l], area[right-1]);
		quicksort2(left, l);
		quicksort2(l+1, right);
	}
}

void output()
{
	ofstream fout("area.out");
	fout << narea << endl;
	quicksort2(0, narea);
	int i;
	for(i = 0; i < narea; i++)
		fout << area[i] << endl;
	fout.close();
}

void main()
{
	input();
	preproc();
	process();
	output();
}