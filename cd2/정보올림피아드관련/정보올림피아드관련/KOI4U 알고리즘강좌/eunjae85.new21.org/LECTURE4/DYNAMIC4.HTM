<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
<head>
<title>Memoization</title>
<meta name="generator" content="Namo WebEditor v3.0">
</head>

<body bgcolor="white" text="black" link="blue" vlink="purple" alink="red">

<p style="line-height:130%;">Memoization</p>
<p style="line-height:130%;">Memoization은 동적 계획법의 테크닉 중의 하나입니다. 
기본적인 골격은 크게 다르지 않지만 점화식을 구현하는 부분을 매우 간편하게 작성할 
수 있다는 장점이 있습니다.</p>
<p style="line-height:130%;">Memoization은 재귀호출을 이용합니다. 물론 재귀의 
깊이가 그리 깊지 않기 때문에(보통의 경우) 스택 오버같은 극한의 사태는 걱정하지 
않으셔도 됩니다. 또한 시간 복잡도 역시 기존의 방법에서의 그것과 같으며, 오히려 
몇몇 문제에 대해서는 더 나은 성능을 보여줍니다.</p>
<p style="line-height:130%;">이 테크닉은 크게 두 가지 아이디어를 기초로 하고 
있습니다.</p>
<p style="line-height:130%;">1. 점화식을 계산하는 부분을 재귀호출로 쉽게 작성할 
수 있다.</p>
<p style="line-height:130%;">2. 이미 계산한 부분을 배열에 저장하면 계산의 중복을 
막을 수 있다.</p>
<p style="line-height:130%;">일단 모든 테이블 배열을 특정한 값으로 초기화시킵니다. 
여기서 특정한 값이란 문제에서 쓰이지 않는 값 (보통 -1이나 32767등등을 씁니다..) 
중 임의로 하나를 고르면 됩니다.</p>
<p style="line-height:130%;">Memoization을 이용하기 위해서 일단 부분문제를 함수로 
하나 만듭니다. 그 함수가...</p>
<ul>
    <p style="line-height:130%;">이전에 계산된 적이 있을때 : 저장된 값을 돌려줌</p>
    <p style="line-height:130%;">이전에 계산된 적이 없을때 : 새로 계산해서 값을 
    저장하고 돌려줌</p>
</ul>
<p style="line-height:130%;">함수의 구조는 문제가 다를지라도 다음과 항상 유사합니다.</p>
<p style="line-height:130%;"><font face="굴림체">function 함수이름 (n)<br>
&nbsp;&nbsp;if table[n] = 아직모름 then<br>
&nbsp;&nbsp;&nbsp;&nbsp;if n이 충분히 작아 쉽게 구할 수 있으면 then<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;table[n] &lt;- ...<br>
&nbsp;&nbsp;&nbsp;&nbsp;else<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;table[n] &lt;- 함수이름 (n-1) + 함수이름(n-2) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{여기서 재귀호출}</font></p>
<p style="line-height:130%;"><font face="굴림체">&nbsp;&nbsp;table[n]을 결과값으로 
되돌려 줌</font></p>
<p style="line-height:130%;">위의 의사코드를 보고 이해하실 수 있으실 지 모르겠네요. 
memoization함수는 점화식의 정의와 똑같이 생겼습니다.</p>
<p style="line-height:130%;">아래 소스는 피보나치 수열의 제 N항을 구하는 프로그램으로 
memoization을 사용하였습니다. 보고 테스트해 보시면 위에서 설명한 내용이 쉽게 
이해가 될 것입니다.</p>
<p style="line-height:130%;"><font face="굴림체">program memoization_test;</font></p>
<p style="line-height:130%;"><font face="굴림체">const<br>
&nbsp;&nbsp;unknown = -1;</font></p>
<p style="line-height:130%;"><font face="굴림체">var<br>
&nbsp;&nbsp;table : array[1..30] of integer;</font></p>
<p style="line-height:130%;"><font face="굴림체">function fibonacci (n : integer) 
: integer;<br>
begin<br>
&nbsp;&nbsp;if table[n] = unknown then begin<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (n = 1) or (n = 2) then<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;table[n] := 1<br>
&nbsp;&nbsp;&nbsp;&nbsp;else <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;table[n] := fibonacci (n - 1) + fibonacci 
(n - 2);<br>
&nbsp;&nbsp;end;</font></p>
<p style="line-height:130%;"><font face="굴림체">&nbsp;&nbsp;fibonacci := table[n];<br>
end;</font></p>
<p style="line-height:130%;"><font face="굴림체">procedure inittable;<br>
var<br>
&nbsp;&nbsp;i : integer;<br>
begin<br>
&nbsp;&nbsp;for i := 1 to 30 do<br>
&nbsp;&nbsp;&nbsp;&nbsp;table[i] := unknown;<br>
end;</font></p>
<p style="line-height:130%;"><font face="굴림체">var<br>
&nbsp;&nbsp;n : integer;<br>
begin<br>
&nbsp;&nbsp;inittable;</font></p>
<p style="line-height:130%;"><font face="굴림체">&nbsp;&nbsp;write ('N = ');<br>
&nbsp;&nbsp;readln (n);</font></p>
<p style="line-height:130%;"><font face="굴림체">&nbsp;&nbsp;writeln ('Fibonacci(n) 
= ', fibonacci(n));<br>
</font>end.</p>
<p style="line-height:130%;">그런데 위의 소스를 보면 아시겠지만 기존의 방법을 
이용한 동적계획법과 비교해 봤을 때 그리 좋은 점을 쉽게 발견할 수 없을 지도 모르겠습니다. 
그럼 왜 memoization을 쓰는 걸까요?</p>
<ul>
    <p style="line-height:130%;">1. 소스의 가독성이 좋아진다. (고로 버그의 위험이 
    줄어든다)</p>
    <p style="line-height:130%;">2. 문제가 다르더라도 프로그램의 구조가 비슷해 
    생산성(?)이 높다</p>
    <p style="line-height:130%;">3. 테이블을 채우는 순서에 대해 고민할 필요가 
    없다.</p>
    <p style="line-height:130%;">4. 점화식의 정의를 그대로 이용할 수 있다.</p>
</ul>
<p style="line-height:130%;">특히 장점이 되는 게 바로 4번입니다. 피보나치 수열은,</p>
<p style="line-height:130%;">F(1) = 1<br>
F(2) = 1<br>
F(N) = F(N-1) + F(N-2)</p>
<p style="line-height:130%;">로 정의됩니다. 그런데 위의 점화식은 소스에서 똑같은 
모양으로 사용되고 있음을 알 수 있습니다. 즉, 우리는 점화식만 세우고 나면 어떻게 
프로그램으로 옮겨야 할 것인지를 고민해야 할 필요가 없다는 것이죠. (사람이 조금 
게을러지긴 합니다..)</p>
<p style="line-height:130%;">위의 소스가 재귀호출을 사용하기 때문에 낯설게 느껴지시는 
분도 계실 것입니다. 하지만 자동차를 배우기 위해서 자동차의 구조를 몽땅 다 알아야 
할 필요는 없듯이, 위의 소스는 그냥 생긴 그대로만 이해하시면 됩니다. 그래도 나는 
원리를 모르면 급성 고혈압으로 쓰러지실 것 같다 하시는 분은, 위의 소스를 약간 
편집해서 이해가 쉽도록 해드리게습니다.</p>
<p style="line-height:130%;"><font face="굴림체">program memoization_test;</font></p>
<p style="line-height:130%;"><font face="굴림체">const<br>
&nbsp;&nbsp;unknown = -1;</font></p>
<p style="line-height:130%;"><font face="굴림체">var<br>
&nbsp;&nbsp;table : array[1..30] of integer;</font></p>
<p style="line-height:130%;"><font face="굴림체">procedure tab (a : integer);<br>
var<br>
&nbsp;&nbsp;i : integer;<br>
begin<br>
&nbsp;&nbsp;for i := 1 to a do write (' ');<br>
end;</font></p>
<p style="line-height:130%;"><font face="굴림체">function fibonacci (n, d : 
integer) : integer;<br>
begin<br>
&nbsp;&nbsp;tab (d);<br>
&nbsp;&nbsp;writeln ('fibonacci(', n, ')?');</font></p>
<p style="line-height:130%;"><font face="굴림체">&nbsp;&nbsp;if table[n] = unknown 
then begin<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (n = 1) or (n = 2) then<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;table[n] := 1<br>
&nbsp;&nbsp;&nbsp;&nbsp;else begin<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;table[n] := fibonacci (n - 1, d + 2) + fibonacci 
(n - 2, d + 2);</font></p>
<p style="line-height:130%;"><font face="굴림체">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tab 
(d);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;writeln ('f(', n, ') = ', table[n - 1], 
' + ', table[n - 2], ' = ', table[n]);<br>
&nbsp;&nbsp;&nbsp;&nbsp;end;<br>
&nbsp;&nbsp;end;</font></p>
<p style="line-height:130%;"><font face="굴림체">&nbsp;&nbsp;fibonacci := table[n];<br>
&nbsp;&nbsp;tab (d);<br>
&nbsp;&nbsp;writeln ('return ', table[n]);<br>
end;</font></p>
<p style="line-height:130%;"><font face="굴림체">procedure inittable;<br>
var<br>
&nbsp;&nbsp;i : integer;<br>
begin<br>
&nbsp;&nbsp;for i := 1 to 30 do<br>
&nbsp;&nbsp;&nbsp;&nbsp;table[i] := -1;<br>
end;</font></p>
<p style="line-height:130%;"><font face="굴림체">var<br>
&nbsp;&nbsp;n : integer;<br>
begin<br>
&nbsp;&nbsp;writeln;<br>
&nbsp;&nbsp;inittable;</font></p>
<p style="line-height:130%;"><font face="굴림체">&nbsp;&nbsp;write ('N = ');<br>
&nbsp;&nbsp;readln (n);</font></p>
<p style="line-height:130%;"><font face="굴림체">&nbsp;&nbsp;fibonacci (n, 0);<br>
end.</font></p>
<p style="line-height:130%;">간단히 동작 원리를 테스트해 볼 수 있도록 고친 소스입니다. 
n=5를 넣었을 때에는 다음과 같이 출력되는데..</p>
<p style="line-height:130%;"><font face="굴림체">N = 5<br>
fibonacci(5)?<br>
&nbsp;&nbsp;fibonacci(3)?<br>
&nbsp;&nbsp;&nbsp;&nbsp;fibonacci(1)?<br>
&nbsp;&nbsp;&nbsp;&nbsp;return 1<br>
&nbsp;&nbsp;&nbsp;&nbsp;fibonacci(2)?<br>
&nbsp;&nbsp;&nbsp;&nbsp;return 1<br>
&nbsp;&nbsp;f(3) = 1 + 1 = 2<br>
&nbsp;&nbsp;return 2<br>
&nbsp;&nbsp;fibonacci(4)?<br>
&nbsp;&nbsp;&nbsp;&nbsp;fibonacci(2)?<br>
&nbsp;&nbsp;&nbsp;&nbsp;return 1<br>
&nbsp;&nbsp;&nbsp;&nbsp;fibonacci(3)?<br>
&nbsp;&nbsp;&nbsp;&nbsp;return 2<br>
&nbsp;&nbsp;f(4) = 2 + 1 = 3<br>
&nbsp;&nbsp;return 3<br>
f(5) = 3 + 2 = 5<br>
return 5</font></p>
<p style="line-height:130%;">f(n) = f(n-1) + f(n-2) = ... 이렇게 나오는 부분은 
기존에 계산되어 있지 않아 새로 계산한다는 뜻입니다.</p>
<p style="line-height:130%;">f(5)를 구하기 위해서 f(3)과 f(4)를 호출하는 것을 
볼 수 있습니다. f(3)은 다시 f(1)과 f(2)를 호출하구요... 위의 출력을 자세히 보시면 
아시겠지만 f(3)은 처음에 한번 계산 되고 나서 다시 호출되었을 때는 다시 계산하지 
않고 이미 계산 했던 값을 돌려줍니다.</p>
<p style="line-height:130%;">memoization은 재귀호출을 이용하기 때문에 약간의 
오버헤드가 있을 수 있습니다. 하지만 필요없는 값은 계산하지 않아서 생기는 시간의 
절약이라는 부수적인 효과도 가지고 있습니다. 즉, 문제의 특성에 따라서 수행성능이 
조금씩 달라지긴 하는데, 보통 동저계획법은 차수가 낮은 다항시간 알고리즘으로 
구현되기 때문에 속도에 크게 구애 받을 필요는 없습니다.</p>
<p style="line-height:130%;">이번 편은 여기서 마치도록 하겠습니다. 조금 내용이 
부족한 감도 없잖아 있습니다만, 기출문제 풀이에서 memoization을 사용하는 소스를 
소개해 드리도록 하겠습니다.</p>
<p style="line-height:130%;">memoization을 이용하면 테이블을 어떤 순서로 채워 
나가야 할지 고민할 필요가 없다는 장점이 있습니다. 하지만 이런 이유로, 문제에 
대해 생각하는 시간이 줄어든다면 큰 일이겠습니다. 평소에 연습하실 때에는 기존의 
보통 방법을 사용하시고, 대회에서 정 필요하시다 싶으시면 그때에만 쓰시기 바랍니다.</p>
<p>&nbsp;</p>
</body>

</html></html>