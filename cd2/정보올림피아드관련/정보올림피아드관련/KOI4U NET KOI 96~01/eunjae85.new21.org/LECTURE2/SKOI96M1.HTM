<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
<head>
<title>KOI 13회 중등부 1.</title>
<meta name="generator" content="Namo WebEditor v3.0">
</head>

<body bgcolor="white" text="black" link="blue" vlink="purple" alink="red">

<table border="0" width="595">
    <tr>
        <td width="383" height="27" bgcolor="#CFD3FF"><p><font size="4"><b>&nbsp;&nbsp;KOI 
            13회 중등부 1. 연속 부분 최대곱</b></font></td>
        <td width="100" height="27" bgcolor="#CFD3FF"><p align="center"><a href="pkoi96m1.htm"><img src="button1.gif"
             width="72" height="22" border="0"></a></td>
        <td width="100" height="27" bgcolor="#CFD3FF"><p align="center"><a href="ckoi96m1.htm"><img src="button3.gif"
             width="72" height="22" border="0"></a></td>
    </tr>
</table>
<ul>
    <p>&nbsp; 
    <table border="0">
            <tr>
                <td width="550"><p style="line-height:150%;"><font size="2">&nbsp;&nbsp;가장 
                기본적으로 생각할 수 있는 풀이는 모든 구간 [i, j]의 곱을 구하는 
                방법이다(i부터 j까지의 구간을 말할 때 [i, j]와 같은 기호를 쓴다). 
                이 방법으로 프로그램을 작성하면 구간 [i, j]를 정하는 데 N^2번의 
                루프를 돌고 곱을 구하는 데 N번의 루프를 돌게 되기 때문에 시간복잡도는 
                O(N^3)이 된다. 그런데 이 문제에서의 N의 최대 크기는 10000이므로, 
                이 알고리즘을 사용해서는 제한시간 내에 답을 구할 수 없다. 따라서 
                더 낮은 시간 복잡도를 갖는 알고리즘을 설계해야 한다. 이 문제는 
                동적 계획법을 이용해 O(N)만에 구할 수 있다. a[i]는 i번째 입력 
                데이터를 나타낸다고 하자. </font></p>
                <p style="line-height:150%;"><font size="2">&nbsp;&nbsp;M[j]를 
                [i, j]구간의 최대 곱이라고 하자. 예를 들어 M[4]는 [1, 4], [2, 
                4], [3, 4], [4, 4] 구<br> 간 중 최대 곱이다. 그럼 우리가 구하고자 
                하는 답은 M[1], M[2], M[3], ... , M[N] 중에 반드시 있을 것이다. 
                즉, 우리는 M[1] ~ N[N]을 구함으로써 문제의 답을 찾을 수 있다. 
                일단 M[1]은 [1, 1]구간의 최대 곱이므로 M[1] = a[1]이다.</font></p>
                <p style="line-height:150%;"><font size="2">&nbsp;&nbsp;M[j]의 
                값은 i가 어떤 수가 될지 알 수 없지만 i가 j보다 작다면 a[i] * 
                a[i+1] * a[i+2] * ... * a[j-1] * a[j]로써 구할 수 있다. 그런데 
                우리는 M[j]가 최대 곱이라고 정의했으므로, a[i] * a[i+1] * a[i+2] 
                * ... * a[j-1]의 값 역시 최대가 되어야 할 것이다(a[j]는 반드시 
                사용해야 하므로).</font></p>
                <p style="line-height:150%;"><font size="2">t = j-1이라고 하자. 
                그렇다면,<br> a[i] * a[i+1] * a[i+2] * ... * a[j-1] = a[i] * 
                a[i+1] * a[i+2] * ... *a[t] = M[t] = M[j-1]</font></p>
                <p style="line-height:150%;"><font size="2">&nbsp;&nbsp;즉, 
                M[j] = M[j-1] * a[j]라는 것을 알 수 있다. 이것은 i가 j보다 작은 
                경우이고, i=j인 경우에는 어떨까? 이 때에는 M[j] = [j, j] = a[j]가 
                될 것이다. i는 j와 같거나 j보다 작은 두 가지 경우 중에 하나이므로, 
                M[j]는 M[j-1] * a[j]또는 a[j]가 될 것이다.</font></p>
                <p style="line-height:150%;"><font face="굴림체" size="2">M[j] 
                = a[1] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(j=1일 
                때)<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M[j-1] * a[j] 
                또는 a[j] 중 큰 값 (j&gt;1일 때)</font></p>
                <p style="line-height:150%;"><font size="2">&nbsp;&nbsp;위의 
                점화식을 가지고 M[1]부터 M[N]까지 차례로 구하면서 최대값을 찾으면 
                된다. 이 문제에서는 모든 수가 양수이지만, 음수값이 있는 문제로 
                바꿔서 풀어보는 것도 재미있을 것이다.</font></td>
        </tr>
    </table>
    <p>&nbsp;</p>
</ul>
</body>

</html></html>