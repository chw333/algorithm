<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0058)http://ace.delos.com/usacoanal/s=1.4.4.9/a=Oi9VZ3OrH8a/61a -->
<HTML><HEAD><TITLE>Analysis 61: Pollutant Control</TITLE>
<META http-equiv=Content-Type content="text/html; charset=ks_c_5601-1987">
<META content="MSHTML 6.00.2600.0" name=GENERATOR></HEAD>
<BODY background="Analysis 61 Pollutant Control.files/bg3.jpg"><IMG height=118 
src="/usaco/cow1.jpg" width=742> 
<CENTER><B><FONT size=7>Pollutant Control</FONT></B><BR>Hal Burch </CENTER>
<P>This is a straight-forward min cut problem. Since we want the minimum set of 
edges in the case of a tie in total cost, multiply the cost of each edge by 1001 
(one more than the maximum number of edges to delete) and add one. Thus, the 
cost of a min cut is the number of edges cut plus 1001 times the sum of the cost 
of the edges cut. Since the max cut can be very large, we must use doubles to 
avoid overflow. 
<P>Determine the max flow using the standard method. To determine a cut 
associated with this flow, look at the residual graph. Flood fill out from the 
start node. The boundary of the flood fill corresponds to one cut in the graph. 
To determine this cut, find all edges that go from a node visited by the flood 
fill to a node not visited by the flood fill. <PRE>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define MAXN 32

/* residual graph */
double graph[MAXN][MAXN];
int nloc; /* number locations */

/* the routes */
int troute[1000][3]; /* start, end, size */
int nroute; /* number routes */

/* was this node visited by the flood fill? */
int vis[1000];

/* augment the graph by a flow */
/* use dijkstra's to determine augmenting path of maximum capacity */
double augment(void)
 {
  double flow[32]; /* the maximum flow to a node */
  int touched[32]; /* have we visited this node? */
  int src[32];     /* where the flow into this node comes from */
  double max;
  int mloc;
  int lv; /* loop variable */
  int t;

  /* initialization */
  memset(flow, 0, sizeof(flow));
  memset(touched, 0, sizeof(touched));

  /* flow to first node is unbounded */
  flow[0] = 2000000000*1000.0 + 1.0;
  while (1)
   {
    /* find node with maximum capacity that hasn't been visited */
    mloc = -1;
    max = 0.9; /* smaller than any node that has a path to it */
    for (lv = 0; lv &lt; nloc; lv++)
      if (!touched[lv] &amp;&amp; flow[lv] &gt; max)
       {
        max = flow[lv];
	mloc = lv;
       }

    if (mloc == -1) return -1; /* no augmented path! */

    /* if best node is maximum capacity node, then we are done */
    if (mloc == nloc-1) break; 

    touched[mloc] = 1; /* mark as visited */
    /* for each adjacent node, see if path through this
       node has higher capacity than the current path for it */
    for (lv = 0; lv &lt; nloc; lv++)
      if (graph[mloc][lv] &gt; flow[lv] &amp;&amp; max &gt; flow[lv])
       { /* better path found */

        src[lv] = mloc;

	flow[lv] = graph[mloc][lv];
	if (flow[lv] &gt; max) flow[lv] = max;
       }
   }

  /* starting at end, augment path */
  for (mloc = nloc-1; mloc &gt; 0; mloc = src[mloc])
   {
    t = src[mloc];

    graph[t][mloc] -= max; /* remove forward arc */
    graph[mloc][t] += max; /* add back arc */
   }

  return max;
 }

/* calculate the flow */
double calc_flow(void)
 {
  double rv = 0.0;
  double t;

  /* just augment until we can't */
  while ((t = augment()) &gt; -0.1)
    rv += t;
  return rv;
 }

/* create a graph with edges in troute */
void make_graph(void)
 {
  int lv;

  memset(graph, 0, sizeof(graph));
  for (lv = 0; lv &lt; nroute; lv++)
    graph[troute[lv][0]][troute[lv][1]] += 1.0+(1001.0*troute[lv][2]);
 }

/* flood fill from this position */
void flood_fill(int pos)
 {
  int lv;

  vis[pos] = 1;

  /* for each neighbor, flood fill if necessary */
  for (lv = 0; lv &lt; nloc; lv++)
    if (!vis[lv] &amp;&amp; graph[pos][lv] &gt; 0.1) flood_fill(lv);
 }

int main(int argc, char **argv)
 {
  FILE *fout, *fin;
  int lv;
  double goal;
  int t;
  double tv;

  if ((fin = fopen("milk6.in", "r")) == NULL)
   {
    perror ("fopen fin");
    exit(1);
   }
  if ((fout = fopen("milk6.out", "w")) == NULL)
   {
    perror ("fopen fout");
    exit(1);
   }

  fscanf (fin, "%d %d", &amp;nloc, &amp;nroute);
  for (lv = 0; lv &lt; nroute; lv++)
   {
    fscanf (fin, "%d %d %d", troute[lv]+0, troute[lv]+1, troute[lv]+2);

    /* I'm using 0-based indexing instead of 1-based */
    troute[lv][0]--;
    troute[lv][1]--;
   }

  make_graph();
  goal = calc_flow();

  /* cost has been multiplied by 1001, so t is the real cost */
  t = (int)(goal / 1001.0);
  fprintf (fout, "%d %d\n", t, (int)(goal - t*1001.0));

  /* find min cut */
  
  /* find all nodes reachable from warehouse 1*/
  flood_fill(0);

  for (lv = 0; lv &lt; nroute; lv++)
   { /* delete all arc from a reachable node to an unreachable one */
    if (vis[troute[lv][0]] == 1 &amp;&amp; !vis[troute[lv][1]])
      fprintf (fout, "%d\n", lv+1);
   }

  return 0;
 }
</PRE>
<CENTER><A href="http://ace.delos.com/usacogate?a=Oi9VZ3OrH8a">USACO Gateway</A> 
| <A href="mailto:kolstad@ace.delos.com">Comment or Question</A> 
</CENTER></BODY></HTML>
