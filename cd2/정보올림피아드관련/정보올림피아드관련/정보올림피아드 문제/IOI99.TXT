
┌───────────────────────────────────┐
│  ▶ 번  호 : 14/26                 ▶ 등록자 : LIM8411               │
│  ▶ 등록일 : 1999년 11월 10일 21:53                                  │
│  ▶ 제  목 : IOI 99년도 문제 한글판..(하이텔에서..)                  │
└───────────────────────────────────┘


번  호 : 245
게시자 : 송기문   (freewild)
등록일 : 1999-11-09 19:11
제  목 : [문제] 99 IOI 한글판 모든 문제          

후..

부삽임다. 한 일이 없어서 IOI'99문제라도 해석판 올려드리겠슴다.
교수님들과 조교형이 해석해준거 약간 땜질했슴다.

--------------

Day 1

Task 1 - 꽃 진열

문제

 꽃가게에서 꽃을 꽃병에 꽃아 진열한다. F개의 서로 다른 꽃이 있고, 그 이상의
꽃병
들이 한줄로 서 있다. 꽃병들은 움직일 수 없고, 왼쪽에서 오른쪽으로 1, 2, ...,
V로 
차례대로 번호가 주어진다. 꽃은 1, 2, ..., F로 번호가 주어진다. 하나의 꽃병에는 
하나의 꽃만 꽂을 수 있다. 작은 번호의 꽃은 그것보다 큰 번호의 꽃보다 왼쪽에
있는 
꽃병에꽂아야 한다.

 어떤 꽃을 어떤 꽃병에 꽂느냐에 따라 점수가 다르다. 이 점수는 표로 주어진다.
빈 
꽃병은 0점으로 한다.


                              꽃병
                    1     2     3     4    5 

           1        7    23    -5   -24   16
     꽃    2        5    21    -4    10   23
           3      -21     5    -4   -20   20

 이럴 경우에는 1번 꽃을 2번 꽃병, 2번 꽃을 4번 꽃병, 3번 꽃을 5번 꽃병에
꽂으면 
23+10+20점으로 최대 점수를 얻을 수 있다. 최대 점수가 나오는 경우가 여러가지가
있
다 해도 그 중 한가지만 출력하면 된다.

 * 조건
 1 <= 꽃의 수 <= 꽃병의 수 <= 100
 -50 <= 점수 <= 50

 * 입력
 파일 : flower.inp
 첫 줄에는 꽃의 수 F와 꽃병의 수 V가 주어진다.
 다음 F개의 줄에는 각각 V개의 정수가 주어진다. (i+1)번째줄의 j번째 수가
COSTij가 
된다.

 * 출력
 파일 : flower.out
 첫 줄에는 최대 점수를 출력한다.
 둘째줄에는 F개의 정수를 출력한다. k번째 정수는 k번째 꽃이 꽃힐 병의 번호이다.

 * 입력 예
 3 5
 7 23 -5 -24 16
 5 21 -4 10 23
 -21 5 -4 -20 20

 * 출력 예
 53
 2 4 5

 * 평가 방법
 제한시간 : 2초
 부분점수 : 없음






Task 2 - 숨겨진 코드 (말장난이 많이 포함되어 있어서 많이 고쳤습니다.)

문제

 코드 단어들의 집합과 텍스트가 주어진다. 코드 단어들은 모호한 방식으로 텍스트
속
에 숨겨져 있다. 모호한 방식이라는 것은 연속적으로 나올 필요가 없다는 말이다.
ABC
라는 코드 단어가 있다고 하면 이 코드 단어는 AxqweBeabcqC이러한 식으로 숨겨져
있
다는 말이다. (대문자 Q와 소문자 q는 다른 글자이다.)

 문제는 코드단어와 텍스트가 주어져 있을 때 텍스트 속에서 코드단어들을 뽑아
가장 
많은 점수를 얻어야 하는 것이다. 길이가 6인 코드단어를 텍스트에서 뽑아내면
6점을 
얻는다. 위에 예에서 A___B____C를 찾을때 총 길이가 12였지만 얻는 점수는 3점뿐이
다. (따라서 효율이 낮다고 할 수도 있다.) 또한, 이러한 뽑아낸 텍스트들이 서로
겹
쳐서는 안된다. 다시말해 위의 예에서 ABC와 abc를 동시에 뽑아낼 수는 없는
것이다.

 * 조건
 1 <= 코드 단어의 수, 각 코드 단어의 길이 <= 100
 주어진 텍스트의 길이는 1 이상 1,000,000 이하이다.
 코드 단어가 숨겨져 있는 문자열은 1,000자 이하여야 한다.
 텍스트에는 10,000개 이하의 코드 단어가 숨겨져 있다.
 qwlkjeAekrjBqwkejC는 ABC의 right-minimal-covering sequence라고 한다. 이 말의
뜻
은 위의 문자열이 ABC의 C와 겹칠 수 밖에 없다는 말이다. qerjlAqrjBlqwkjCqrjC는
AB
C의 right-minimal-covering sequence가 아니라는 뜻이다. 이러한
right-minimal-cove
ring sequence들의 수는 텍스트의 한 글자마다 2,500개를 넘지 않는다. (상당히
이해
가 안가시겠지만 그리 중요하지는 않을 수도 있습니다.)

 * 입력
 파일 : words.inp, text.inp
 words.inp
 첫줄에는 코드 단어의 수가주어지고 다음줄부터 한줄씩 코드단어들이 주어진다.
 text.inp
 한줄로 이루어져 있고 텍스트가 주어진다.

 * 출력
 파일 : codes.out
 첫 줄은 얻어진 최대 점수를 적는다.
 둘째줄 부터 그 점수를 구성하고 있는 구성 요소들을 적는다. 각 줄은 세개의
정수로 
이루어 져야 하는데 첫 번째 정수는 코드 단어의 번호, 두번째 정수는 텍스트의
몇번
째 위치에 그 코드 단어의 첫번째 글자가 있는가, 세번째 정수는 텍스트의 몇번째
위
치에 그 코드 단어의 마지막 글자가 있는가 이다.

 * 입력 예
 words.inp
 4
 RuN
 RaBbit
 HoBbit
 StoP

 text.inp
 StXRuYNvRuHoaBbvizXztNwRRuuNNP
    ~~~~ ~~~~~~~~~~~~~  ~~~~~

 * 출력 예
 12
 2 9 21
 1 4 7
 1 24 28

 * 평가 방법
 제한시간 : 10초
 부분점수 : 없음






Task 3 - 지하 도시

 문제

 당신은 지하도시에 갇혀있다. 이 지하도시에서 방황하던 중 운 좋게도 이 지역의
지
도를 발견하였으나, 당신은 그 지도의 어느쯤에 당신이 있는지 알지 못한다. 우리는 
지하 도시를 탐색하면서 지도가 처음 발견된 위치를 알아내려고 한다. (다행히도
나침
판이 있어서 방향을 알 수 있고, 지도에도 동서남북이 표시되어 있다.)
 지하도시의 지도는 직사각형의 그리드(grid)로 표현되어 있다. 각각의 칸은 'O'로
표
시된 빈공간과 'W'로 표시된 벽으로 나타나 있다.
 탐색의 시작은 start 프로시져를 호출함으로써 시작된다. 이후 우리는 함수 look과 
프로시져 move만을 이용해서 지하도시를 탐색한다.
 즉, 프로그램 내에서 당신은 제공된 라이브러리를 사용하여야 한다. look과 move는 
매개변수가 있을 것인데, 그 매개변수는 북('N'), 남('S'), 동('E'), 서('W')중
하나
이다. 예를 들어 당신의 프로그램에서 look('N')을 호출하였다고 하자.만일 그
답이 
'O'라면 현재 위치와 이웃한 북쪽에 빈 공간이 있다는것이고 'W'를 리턴하였다면
벽일 
것이다.
 그리고 당신은 move( dir )를 이용하여 4방향중 한곳으로 '한칸'을 움직일 수
있다. 
문제는 최소 횟수의 'look' 함수를 이용하여 처음 위치를 알아내는 것이다. 처음
위치
를 알았으면 finish (x, y) 함수를 호출하여 그 결과를 보고한다. 여기서 x는 수평,
y
는 수직 성분의 좌표를 나타낸다.

 * 조건
 3 <= 지도의 가로 크기 U, 지도의 세로 크기 V <= 100
 도시는 항상 벽(W)로 둘러싸여 있고 이는 지도에 포함된다.
 입력 파일에 나타난 지도의 왼쪽-아래(남서쪽)의 좌표가 1, 1 이고 오른쪽-위(북동
쪽)의 좌표가 U, V이다.

 * 입력
 파일 이름 : under.inp
 첫 줄에는 U와 V가 주어진다.
 이하 V개의 라인은 지도의 수평방향의 상태를 나타낸다. V-y+2번째 라인에 있는
x번
째 문자는 지도의 (x, y)에 관한 정보를 가지고 있다.
 출발 위치는 항상 빈 공간 'O' 이다.

 * 출력
 출력파일은 없다. 당신이 구한 초기 위치는 finish(x, y)를 호출함으로 보고되어야 
한다.

 * 입력 예
 5 8
 WWWWW (5,8)
 WWWOW
 WWWOW
 WOOOW
 WOWOW
 WOOWW
 WWOOW
 WWWWW
(1,1)

 * 풀이 예 (for C)
 start();
 look('N');     // 리턴 값 = 'W'
 look('E');     // 리턴 값 = 'O'
 move('E');
 look('E');     // 리턴 값 = 'W'
 finish (3, 5);
  (매개변수와 리턴값은 모두 '대문자' 이다.)

 * 평가 방법
 제한시간 : 5초
 부분점수 : 있음
  look 함수를 호출한 횟수가 N번이라고 하고 정해져 있는 가장 좋은 답을 M이라고
하
자. N이 M보다 작다면 만점을 받는다. M보다는 크지만 2M 미만이면 그의 비례해서
부
분점수를 얻을 수있다. 2M 보다도 크다면 0점을 얻는다.
 당신이 벽속으로 이동하려 한다던가, 'N', 'E', 'S', 'W'외에 매개변수로 함수를
호
출할 시에는 그 예에는 0점을 얻는다.

 * 스스로 테스트 해보기 위해서는
 place.txt에 당신의 초기 위치를 적어두자. 그러면 finish함수를 호출함으로
인해서 
result.txt에 당신이 호출한 look 함수의 횟수가 나타날 것이다. 혹시라도 함수를
잘
못 호출했다면 Error!가 출력되어 있을 것이다.






Day 2

Task 1 - 교통 신호등 (문제 이해가 어렵기 때문에 번역판을 그대로 올립니다.)

 문제
 딩지빌(Dingiville)이란 도시의 교통신호는 이상하게 되어 있다. 도로와 교차로가
있
고, 두 교차로 사이에는 최대 하나의 도로가 있다. 한 교차로에서 다시 그 교차로로 
한번에 연결되는 도로는 없다. 도로는 어느 방향으로 지나든지 같은 시간이 걸린다. 
각 교차로에는 신호등이 하나씩 있는데, 신호등의 불빛 색깔은 파란색(blue)이거나
보
라색(purple)이다. 신호등은 한 색이 얼마동안 켜져 있다가 다른 색이 얼마동안 켜
있
기를 반복하면서 색깔이 주기적으로 변한다. 두 교차로의 각 신호등이 같은 색일 때
만, 차는 그 두 교차로를 연결하는 도로에 들어갈 수 있다. 신호등이 바뀌는 바로
그 
순간에 차가 교차로에 도착하면, 그 차는 새로 바뀐 신호등 색깔을 따라야 한다.
차는 
신호등 때문에 교차로에서 기다릴 수도 있다. 다음 정보를 갖는 지도가 주어진다.

 각 도로를 지나는 데 걸리는 시간 (정수)
 각 교차로에 대해서 파란색이 켜있는 시간과 보라색이 켜있는 시간 (정수)
 각 신호등의 초기 색깔과 그 초기 색깔이 유지되는 시간

 출발 교차로의 도착 교차로가 주어질 때, 두 교차로 사이를 최소시간으로 갈 수
있는 
경로를 찾는 것이 문제이다. 그런 경로가 여러 개 있으면 그 중에서 하나만
출력한다.

 * 조건
2 <= N <= 300. N은 교차로의 수. 교차로들은 1, 2, ..., N으로 번호가 주어진다.
 1 <= M <= 14000. M은 도로의 수
 1 <= l_ij <= 100. l_ij는 교차로 i에서 j로, 그 두 교차로를 연결하는 도로를
이용
하여 가는데 걸리는 시간.
 1 <= t_ic <= 100. t_ic는 교차로 i의 신호등이 색깔 c로 켜져 있는 시간.
신호등이 
파란색이면 인덱스 c는 B이고, 보라색이면 P이다.
 1 <= r_ic <= t_ic, r_ic는 교차로 i의 신호등이 초기색깔 c로 유지되는 시간.

 * 입력
 파일 이름 : lights.inp
 첫 줄에는 출발 교차로의 번호와 도착 교차로의 번호가 주어진다.
 둘째줄에는 N, M이 주어진다.
 다음 N 줄에는 교차로의 정보가 주어진다. C_i, r_ic, t_iB, t_iP가 주어지는데
각각 
초기색깔, 초기색깔 유지시간, 파란색일때 유지시간, 빨간색일때 유지시간이 주어진
다.
 다음 M 줄에는 도로의 정보가 주어진다. 각 줄은 i, j, l_ij로 이루어 지는데
교차로 
i와 교차로 j를 연결하는 도로를 나타낸다.

 * 출력
 파일 이름 : lights.out
 경로가 있다면
 첫 줄에는 최소시간 경로의 시간을 나타낸다.
 둘째 줄에는 경로가 지나가는 교차로들의 번호를 출력한다.
 없다면, 첫줄에 0만을 출력한다.

 * 입력 예
 1 4
 4 5
 B 2 16 99
 P 6 32 13
 P 2 87 4
 P 38 96 49
 1 2 4
 1 3 40
 2 3 75
 2 4 76
 3 4 77

 * 출력 예
 127
 1 2 4

 * 평가방법
 제한시간 : 2초
 부분점수 : 없음






Task 2 - 평평하게 만들기

 문제
 수평으로 늘어선 N개의 파일(pile)을 가지고 혼자하는 게임이 있는데, 각 파일에는
0
개 혹은 몇개의 칩이 쌓여져 있다. 이 게임에서 할 수 있는 동작은 특정한 파일에서 
몇개의 칩을 선택하는 것으로 이루어 진다. p번째 파일에서 m개의 칩을 선택했다고
하
면 (단, 현재 p번째 있는 칩의 수가 2m보다 커야 한다.) p 번째 파일에서 2m개의
칩을 
들어낸 뒤, 그 칩을 각각 p-1번째와 p+1번째에 m씩 얹는 것으로 된다. 만일,
p=1이거
나 n이라면 (즉, 인접한 파일이 한개밖에 없는 경우에는) 그저 m개를 들어서 인접한 
파일에 얹으면 된다.
 이 게임의 목적은 이러한 기본 동작을 가능한 적게 사용해서 각 파일의 높이를
모두 
같도록 하는 것이다. 동작횟수가 같은 것이 여러게 있다면 그 중 하나만 출력하면
된
다.

 5개의 파일에 0, 7, 8, 1, 4 의 칩이 있을때 동작 p=2, m=2를 하면 2, 3, 10, 1,
4의 
상태가 된다.

 * 조건
 주어진 입력 파일들은 최대 10,000번 이하의 동작으로 반드시 평평하게 할 수
있다.
 2 <= N <= 200
 0 <= C_i <= 2000. C_i는 초기에 i번째 파일에 있는 칩의 수를 나타낸다.

 * 입력
 파일이름 : flat.inp
 첫번째 줄에는 N이 주어지고 두번째 줄에는 한 줄에 N개의 정수가 주어진다. i번째 
수가 C_i이다.

 * 출력
 파일이름 : flat.out
 첫번째 줄에는 기본 동작의 수 M을 나타내고
 그 다음 M개의 각 라인에 한 동작을 표시하는 두 정수 p와 m을 출력한다.

 * 입력 예
 5
 0 7 8 1 4

 * 출력 예
 5
 5 2
 3 4
 2 4
 3 1
 4 2

 * 평가 방법
 제한시간 : 3초
 부분점수 : 있음
  당신이 구한 동작 횟수를 x라고 하고 채점프로그램이 가지고 있는 답을 y라고 할 
때, x가 y보다 작다면 만점을 받는다. 그리고 x가 1.5y보다 작을 때까지 비례해서
부
분점수를 얻으며 1.5y보다 크면 0점을 얻는다.






Task 3 - 땅 찾기
 비행장을 건설히가 위한 부지를 결정하려고 한다. 그 지역의 지도가 주어져 있는데 
그 지도에 주어져 있는 숫자는 그 지역의 높이를 나타낸다. 문제는 아래의 조건을
만
족하면서 면적이 최대인 직사각형 영역을 찾는 것이다.
a) 이 영역의 가장 높은 지역과 가장 낮은 지역의 높이의 차이는 주어진 한계값
C보
다 반드시 작거나 같아야 한다.
 b) 이영역의 너비 (즉, 서-동방향의 지역의 수) 는 최대 100이다.

 하나 이상이라도 한개만 출력하면 된다.

 * 조건
 1 <= U, V <= 700  U는 서-동 방향의 지역의 수, V는 남-북 방향의 지도의 수이다.
 0 <= C <= 10
 -30000 <= H_xy <= 30000  H_xy는 좌표 (x, y)의 높이이다.
 지도의 남서쪽(왼쪽 아래) 코너의 지역 좌표는 (1, 1)이고 북동쪽 (오른쪽 위)
코너
의 지역 좌표는 (U, V) 이다.

 * 입력
 파일이름 : land.inp
 첫 줄에는 U, V, C가 주어진다.
 그 다음 V개의 줄에 x=1, ..., U에 대한 정수 H_xy가 주어진다. 자세히 말하면
H_xy
는 입력 파일의 (V-y+2)번째 줄에서 x번째 수이다.

 * 출력
 파일이름 : land.out
 찾은 영역의 위치를 나타내는 4개의 정수 Xmin, Ymin, Xmax, Ymax를 표시한다.
남서
쪽 코너와 북동쪽 코너를 출력하는 것이다.

 * 입력 예 (귀찮아서 고칩니다.)
 5 6 0
 15 14 14 14 14 (5,6)
 13 13 15 16 14
 13 13 14 15 14
 13 13 16 17 10
 10 12 15 13 14
 14 14 14 14 14
(1,1)

 * 출력 예
 1 3 2 5

 * 평가 방법
 제한시간 : 130초
 부분점수 : 없음


체 엔터를 안쳐서 이상한 출력이 -_-
알아서 보세여

