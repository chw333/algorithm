<html>

<head>
<meta http-equiv="content-type" content="text/html; charset=ks_c_5601-1987">
<title>동적 프로그래밍과 그리디 알고리즘 (Greedy Algorithms)의 비교</title>
</head>

<body bgcolor="white" text="black" link="blue" vlink="purple" alink="red">
<p align="center"><font color="#0066CC" size="5"><b>동적 프로그래밍과 다른 알고리즘</b></font></p>
<p>&nbsp;</p>
<p><font size="2">동적 프로그래밍과 그리디 알고리즘 (Greedy Algorithms)의 비교</font></p>
<p><font size="2">동적 프로그래밍</font></p>
<p><font size="2">장점 : 결정은 모든 가능성을 고려하여 결정한다. 따라서 동적 
프로그래밍의 결과는 항상 최적의 결과를 얻을 수 있다.</font></p>
<p><font size="2">단점 : 많은 결정 순서들이 생성된다. 그러므로 동적 프로그래밍을 
구현하기 위해서 메모리 공간을 많이 필요하다.</font></p>
<p><font size="2">&nbsp;</font></p>
<p><font size="2">그리디 알고리즘장점 : 가장 간단한 설계방법이고, 좀더 다양한 
문제들에 적용할 수 있다.</font></p>
<p><font size="2">단점 : 단계별로 진행되어 각 단계에서는 현재 상태에서 가장 
최적이라고 판단되는 결정을 내린다. 이 때 전체적으로 최적인지 여부는 검사하지 
않고 현재 상태의 입장에서만 보았을 때 가장 최적이라고 판단되는 결정을 내린다. 
즉 그리디 알고리즘은 문제에 따라 최적해를 구할 수 있고, 그렇지 않을 수도 있다.</font></p>
<p><font size="2">&nbsp;</font></p>
<p><font size="2">동적 프로그래밍과 분할 정복 기법 (Divide and Conquer)의 비교</font></p>
<p><font size="2">분할 정복 방법은 동적 프로그래밍과 비록 상당히 비슷하지만 
개념상 약간의 차이를 가진다. 즉 분할 정복 방법은 주어진 문제를 독립적인 부문제 
(Sub-problem)으로 나누어 분할된 작은 문제를 완전히 독립적인 문제로 간주하고 
풀어내는 것이다. 하지만 동적 프로그래밍은 부문제을 한번 해결하고 그 구한 결과를 
테이블에 저장하여 더 큰 문제를 푸는 데에 이용한다. 예를 들어 퀵소트와 같은 분할 
정복 기법은 주어진 문제를 파티션 (피보트 원소를 이용하여 입력을 두 개로 쪼갬) 
작업을 통해 작은 두개의 문제를 생성하고, 이 두 문제를 완전히 독립적인 문제로 
간주하여 다시 반복 수행하는 것이다. 하지만, 동적 프로그래밍은 앞에서 살펴본 
가방 채우기 문제와 같이 작은 가방에 적은 수의 보석으로 얻을 수 있는 최적의 해를 
조금 더 큰 가방과 더 많은 보석의 문제를 풀는데 사용하는 것이다. 이러한 방식으로 
가방을 조금씩 늘려가고 보석의 수를 늘려감으로써 우리가 원하는 문제, 즉 주어진 
가방과 보석을 가지고 최적의 가방채우기를 할 수 있는 답을 얻게 되는 것이다.</font></p>
</body>

</html>
