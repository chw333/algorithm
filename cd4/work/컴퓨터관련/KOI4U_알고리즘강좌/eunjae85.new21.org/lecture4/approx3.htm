<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
<head>
<title>KOI 13회 중등부 1.</title>
<meta name="generator" content="Namo WebEditor v3.0">
</head>

<body bgcolor="white" text="black" link="blue" vlink="purple" alink="red">

<table border="0" width="595">
    <tr>
        <td width="589" height="27" bgcolor="#CFD3FF"><p><font size="4"><b>&nbsp;&nbsp;휴리스틱을 
            알려주마 (3) - 백트래킹 1</b></font></td>
    </tr>
</table>
<ul>
    <p>&nbsp; 
    <table border="0">
            <tr>
                <td width="550"><p style="line-height:150%;"><font size="2">&nbsp;&nbsp;백트래킹은 
                휴리스틱이라기 보다는 exact method로 보아야 합니다. 즉 항상 
                최적해를 찾는 알고리즘 설계법이라는 것이죠. </font><font size="2"
                 color="red">백트래킹의 기본 아이디어는 &quot;가능성이 있는 
                해를 전부 탐색한다&quot;입니다.</font><font size="2"> 모든 가능성을 
                살펴보는 방법이니 당연히 최적해가 나올 수밖에 없겠지요. 하지만 
                정보올림피아드의 입장에서 보면, 이것이 항상 성립하는 것이 아닙니다. 
                왜냐하면 제한시간이라는 것이 있기 때문입니다.</font></p>
                <p style="line-height:150%;"><font size="2">&nbsp;&nbsp;문제를 
                해결하고자 하는 입장에서 보았을 때, 꼭 답의 좋고 나쁨만이 해결 
                방법 선택의 기준이 되는 것은 아닙니다. 그 외에 고려해야 할 중요한 
                사항 중 하나가 바로 &quot;답을 찾는 시간(속도)&quot;입니다. 
                아무리 좋은 답을 내는 알고리즘이라 하더라도 그 속도가 너무 느리면 
                안되겠지요. 그리고 그 문제는 정보올림피아드에서는 &quot;제한시간&quot;으로 
                나타납니다. 백트래킹은 일반적으로 모든 가능성을 다 체크하기 
                때문에 속도가 느릴 수밖에 없습니다. 따라서 데이터의 크기가 조금만 
                커져도 제한시간을 넘겨 버릴 수밖에 없는 거지요.</font></p>
                <p style="line-height:150%;"><font size="2">&nbsp;&nbsp;따라서 
                백트래킹 사용시 제한시간 이내에 모든 가능성을 탐색하지 못한다면(이 
                말은 최적해를 찾았다는 뜻이조..) 반드시 실행 도중에 프로그램 
                수행을 끝내야 합니다. 따라서 최적해가 아닌, 지금까지 발견한 
                해 중 가장 좋은 해를 출력해야 합니다. 백트래킹이 항상 최적해를 
                찾는 알고리즘 설계법이면서 근사해를 내는 것은 바로 이런 이유입니다.</font></p>
                <p style="line-height:150%;"><font size="2">&nbsp;&nbsp;백트래킹은 
                재미있는 것이, 많은 문제들에 대해 거의 비슷비슷한 구조를 가지고 
                있다는 것입니다. 따라서 코딩하기도 한결 수월하구요. 물론 몇몇 
                문제들이 이 &quot;전형적인 유형&quot;과는 다른 구조를 요구하기도 
                합니다. 무슨 말인고 하니 모든 문제가 똑같이 풀리는 것은 아니라는 
                것이죠. </font></p>
                <p style="line-height:150%;"><font size="2">&nbsp;&nbsp;이제 
                제가 즐겨 사용하는 백트래킹 구조에 대해서 설명하겠습니다(똑같이 
                따라하란 말은 아닙니다. 그냥 제가 써보니까 좋았더라는 것이죠). 
                </font><font size="2" color="red">일반적으로 백트래킹은 N번의 
                선택을 반복하는 구조를 가지고 있습니다</font><font size="2">. 
                예를 들어서 TSP를 보면(이젠 지겹네요..) 다음 이동할 도시는 어디인가.. 
                라는 선택을 N개의 도시에서 한 번씩 하게 되지요. 그럼 우리는 
                재귀호출을 이용해서 이 것을 구현할 수 있습니다. 보통 백트래킹의 
                구조는...</font></p>
                <ul>
                    <p style="line-height:150%;"><font size="2"><b>백트래킹 
                    (d)<br> &nbsp;&nbsp;&nbsp;if d &gt; N then <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;답을 
                    갱신<br> &nbsp;&nbsp;&nbsp;else<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for 
                    (선택할 수 있는 방법들에 대해)<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if 
                    (이 방법이 가능성이 있다면)<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 
                    방법을 d번째 선택으로 결정<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;백트래킹 
                    (d+1)</b></font></p>
                </ul>
                <p style="line-height:150%;"><font size="2">&nbsp;&nbsp;일단 
                차근차근 뜯어보기로 하지요. 백트래킹 (d)를 호출한다는 것은 d번째 
                선택을 결정하라는 뜻입니다. 맨 처음에 시작할 때에는 백트래킹 
                (1)을 호출해야 할 겁니다.</font></p>
                <p style="line-height:150%;"><font size="2">&nbsp;&nbsp;d가 
                N보다 크다는 말은 무슨 뜻인가요? 바로 N번의 선택을 모두 마쳤다는 
                것이죠. 이렇게 찾은 해는 무조건 지금까지 구했던 답보다 더 좋은 
                답입니다. 그 이유에 대해서는 조금 뒤에 설명하기로 하구요. 아무튼 
                지금 찾은 답이 예전까지의 답 보다 좋으니까 당연히 갱신이 되어야겠지요.</font></p>
                <p style="line-height:150%;"><font size="2">&nbsp;&nbsp;그럼 
                이제 d가 N보다 크지 않은 경우... 즉 d번째 선택을 해야 하는 경우를 
                보겠습니다. 백트래킹의 기본 아이디어가 모든 가능성을 전부 탐색하는 
                거니까 d번째 선택에서도 모든 가능성을 고려해 봐야 할 것입니다. 
                이제 if (...) 부분. 이 부분은 따로 설명이 필요할 것 같네요. 
                일단 이 부분에서 책갈피를 끼웁시다.</font><font size="2"><i> 
                </i></font><font size="2"><b><i>&gt;&gt;&gt; 책갈피 -_- &lt;&lt;&lt;</i></b></font></p>
                <p style="line-height:150%;"><font size="2">&nbsp;&nbsp;0-1 
                냅색 문제를 생각해 보죠. 배낭의 크기는 100이고, a, b, c각 물건의 
                부피는 (50, 70, 40)입니다. 각 물건의 가격은 (6, 10, 5)이구요. 
                해는 {a, b, c}의 부분집합으로 나타낼 수 있습니다. 따라서 생길 
                수 있는 해는,</font></p>
                <p align="center" style="line-height:150%;"><font size="2">{}, 
                {a}, {b}, {c}, {a, b}, {a, c}, {b, c}, {a, b, c} </font></p>
                <p style="line-height:150%;"><font size="2">&nbsp;&nbsp;이렇게 
                여덟가지입니다. 이것들 각각을 우리는 solution(해)이라고 부릅니다. 
                </font><font size="2" color="red">백트래킹이란 모든 가능성들을 
                탐색하여 모든 solution을 찾아내는 일종의 탐색법입니다. </font><font
                 size="2">가능성을 따지지 않는 경우의 상태공간은 다음과 같습니다.</font></p>
                <p align="center" style="line-height:150%;"><font size="2"><img src="approx3-1.gif"
                 width="469" height="326" border="0"></font></p>
                <p align="left" style="line-height:150%;"><font size="2">&nbsp;&nbsp;위와 
                같은 그림을 우리는 상태공간 트리라고 부릅니다(나무와 닮았죠.. 
                뒤집어서 보면). 그런데 위에서 찾은 8개의 solution들이 전부다 
                답이 될 수 있느냐 하면 그건 아닙니다. {a, b, c}는 척 봐도 배낭의 
                부피를 넘겨 버리죠. 배낭의 부피를 초과하지 않는 solution은 다음과 
                같습니다.</font></p>
                <p align="center" style="line-height:150%;"><font size="2">{}, 
                {a}, {b}, {c}, {a, c}</font></p>
                <p align="left" style="line-height:150%;"><font size="2">&nbsp;&nbsp;위의 
                다섯 가지 해 이외에는 전부 배낭의 부피를 넘겨 버리죠. 우리는 
                위의 다섯가지 해들을 feasible solution이라고 부릅니다. 즉, 문제의 
                조건을 벗어나지 않는 해라는 뜻입니다. 그리고 당연히 최적해(optimal 
                solution)은 위의 feasible solution 중의 하나일 것입니다.</font></p>
                <ul>
                    <p align="left" style="line-height:150%;"><font size="2">자꾸 
                    영어 써서 죄송합니다 -_-; 가급적이면 쓰지 않으려고 하는데... 
                    그 영어 단어를 모를 경우에는 인터넷이나 책에서 자료를 찾아 
                    볼 때 엄청난 혼란이 올 수 있거든요. 그리고 영어로 된 용어 
                    하나에도 한글로 여러 가지 번역을 하기 때문에(예를 들어 greedy 
                    method - 탐욕법, 욕심쟁이 방법, 그리디 등) 원래 영어 단어를 
                    모르면 의미 파악이 힘든 경우도 있습니다. 어쩔 수 없네요.</font></p>
                </ul>
                <p align="left" style="line-height:150%;"><font size="2">&nbsp;&nbsp;위에서 
                해와 가능성 있는 해(feasible solution)의 관계를 그림으로 나타내면 
                다음과 같을 것입니다..</font></p>
                <p align="center" style="line-height:150%;"><font size="2"><img src="approx3-2.gif"
                 width="371" height="229" border="0"></font></p>
                <p align="left" style="line-height:150%;"><font size="2">&nbsp;&nbsp;여기서 
                우리는 한가지 사실을 알 수 있습니다. 우리는 최적해 또는 그와 
                비슷한 근사해를 찾는 것이 목적이니까, </font><font size="2" color="red">문제의 
                조건을 벗어나는 해에 대해서는 검사를 할 필요가 없다</font><font
                 size="2">는 거죠. 따라서 백트래킹 도중에 어떤 선택이 문제의 
                조건을 벗어나게 한다면 그 선택은 할 필요가 없다는 뜻입니다. 
                우리는 이를 이용해 백트래킹의 수행시간을 획기적으로 줄일 수 
                있습니다. 위에서 어떤 선택이 문제의 조건을 벗어나는지는 (배낭의 
                최대 부피 &lt; 현재 채운 배낭의 부피 + 물건 d의 부피)가 성립하는지를 
                통해 알 수 있습니다. 문제의 조건을 벗어나 버린다면 다시 상태공간을 
                거슬러 올라 가야겠죠(여기에서 backtracking이란 이름이 유래했습니다). 
                위의 그림에서 문제의 조건을 벗어나는지에 대한 검사를 할 경우, 
                상태 공간 트리는 다음과 같은 모양이 될 것입니다.</font></p>
                <p align="center" style="line-height:150%;"><font size="2"><img src="approx3-3.gif"
                 width="390" height="440" border="0"></font></p>
                <p align="left" style="line-height:150%;"><font size="2">&nbsp;&nbsp;위의 
                그림에서 빨간색 선으로 잘려 나간 부분이 문제의 조건을 벗어나는 
                선택을 하는 경우입니다. 이렇게 선택을 제한을 통해서 우리는 백트래킹을 
                더 빠르게 수행할 수 있습니다. 백트래킹을 빠르게 수행하기 위한 
                이유는 다른게 아닙니다. 가급적이면 제한시간 내에 모든 상태 공간을 
                탐색해 최적해를 찾자는 것이죠. 물론 최적해까지는 아니더라도 
                더 넓은 상태 공간을 탐색할 수 있게 되기 때문에 더 최적해에 가까운 
                해를 얻을 수 있을 것입니다.</font></p>
                <p align="left" style="line-height:150%;"><font size="2">&nbsp;&nbsp;흠... 
                왜 이리 길어지는 거냐!! &gt;_&lt; 백트래킹 하면 빼 놓을 수 없는 
                바운딩 함수(bounding function)에 대해서는 다음 회에 살펴보기로 
                하죠. 후아... 오늘 한 내용은 조금 어렵지 않았나 싶네요. 하지만 
                N-queen을 작성하실 수 있는 정도의 분이시라면 충분히 이해하실 
                수 있도록 했습니다. N-queen은 백트래킹의 기초이니 모르시는 분은 
                먼저 이걸 공부하도록 하세요.</font></p>
                <p align="left" style="line-height:150%;"><font size="2">&nbsp;&nbsp;그럼 
                다음 이 시간에 다시 만나요. 뽀뽀뽀 친구들 안녕 -_-/</font></td>
        </tr>
    </table>
    <p>&nbsp;</p>
</ul>
</body>

</html></html>